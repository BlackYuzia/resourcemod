// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_gamenetworkingui.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "steamnetworkingsockets_messages.pb.h"
#include "steamdatagram_messages_sdr.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fgamenetworkingui_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fgamenetworkingui_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_steammessages_5fgamenetworkingui_2eproto;
class CGameNetworkingUI_ConnectionState;
struct CGameNetworkingUI_ConnectionStateDefaultTypeInternal;
extern CGameNetworkingUI_ConnectionStateDefaultTypeInternal _CGameNetworkingUI_ConnectionState_default_instance_;
class CGameNetworkingUI_GlobalState;
struct CGameNetworkingUI_GlobalStateDefaultTypeInternal;
extern CGameNetworkingUI_GlobalStateDefaultTypeInternal _CGameNetworkingUI_GlobalState_default_instance_;
class CGameNetworkingUI_Message;
struct CGameNetworkingUI_MessageDefaultTypeInternal;
extern CGameNetworkingUI_MessageDefaultTypeInternal _CGameNetworkingUI_Message_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class CGameNetworkingUI_GlobalState final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_GlobalState) */ {
 public:
  inline CGameNetworkingUI_GlobalState() : CGameNetworkingUI_GlobalState(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_GlobalState(::google::protobuf::internal::ConstantInitialized);

  CGameNetworkingUI_GlobalState(const CGameNetworkingUI_GlobalState& from);
  CGameNetworkingUI_GlobalState(CGameNetworkingUI_GlobalState&& from) noexcept
    : CGameNetworkingUI_GlobalState() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_GlobalState& operator=(const CGameNetworkingUI_GlobalState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_GlobalState& operator=(CGameNetworkingUI_GlobalState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_GlobalState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_GlobalState* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_GlobalState*>(
               &_CGameNetworkingUI_GlobalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CGameNetworkingUI_GlobalState& a, CGameNetworkingUI_GlobalState& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_GlobalState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_GlobalState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_GlobalState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_GlobalState>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CGameNetworkingUI_GlobalState& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CGameNetworkingUI_GlobalState& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CGameNetworkingUI_GlobalState";
  }
  protected:
  explicit CGameNetworkingUI_GlobalState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_GlobalState)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};// -------------------------------------------------------------------

class CGameNetworkingUI_ConnectionState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_ConnectionState) */ {
 public:
  inline CGameNetworkingUI_ConnectionState() : CGameNetworkingUI_ConnectionState(nullptr) {}
  ~CGameNetworkingUI_ConnectionState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_ConnectionState(::google::protobuf::internal::ConstantInitialized);

  CGameNetworkingUI_ConnectionState(const CGameNetworkingUI_ConnectionState& from);
  CGameNetworkingUI_ConnectionState(CGameNetworkingUI_ConnectionState&& from) noexcept
    : CGameNetworkingUI_ConnectionState() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_ConnectionState& operator=(const CGameNetworkingUI_ConnectionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_ConnectionState& operator=(CGameNetworkingUI_ConnectionState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_ConnectionState& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_ConnectionState* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_ConnectionState*>(
               &_CGameNetworkingUI_ConnectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CGameNetworkingUI_ConnectionState& a, CGameNetworkingUI_ConnectionState& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_ConnectionState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_ConnectionState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_ConnectionState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_ConnectionState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_ConnectionState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_ConnectionState& from) {
    CGameNetworkingUI_ConnectionState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_ConnectionState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CGameNetworkingUI_ConnectionState";
  }
  protected:
  explicit CGameNetworkingUI_ConnectionState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionKeyFieldNumber = 1,
    kIdentityLocalFieldNumber = 4,
    kIdentityRemoteFieldNumber = 5,
    kCloseMessageFieldNumber = 15,
    kStatusLocTokenFieldNumber = 16,
    kSdrpopidLocalFieldNumber = 21,
    kSdrpopidRemoteFieldNumber = 22,
    kAddressRemoteFieldNumber = 23,
    kP2PRoutingFieldNumber = 24,
    kE2EQualityLocalFieldNumber = 30,
    kE2EQualityRemoteFieldNumber = 31,
    kFrontQualityLocalFieldNumber = 40,
    kFrontQualityRemoteFieldNumber = 41,
    kAppidFieldNumber = 2,
    kConnectionIdLocalFieldNumber = 3,
    kConnectionStateFieldNumber = 10,
    kStartTimeFieldNumber = 12,
    kCloseTimeFieldNumber = 13,
    kCloseReasonFieldNumber = 14,
    kTransportKindFieldNumber = 20,
    kPingInteriorFieldNumber = 25,
    kPingRemoteFrontFieldNumber = 26,
    kPingDefaultInternetRouteFieldNumber = 27,
    kE2EQualityRemoteInstantaneousTimeFieldNumber = 32,
    kE2EQualityRemoteLifetimeTimeFieldNumber = 33,
    kFrontQualityRemoteInstantaneousTimeFieldNumber = 42,
    kFrontQualityRemoteLifetimeTimeFieldNumber = 43,
  };
  // optional string connection_key = 1;
  bool has_connection_key() const;
  void clear_connection_key() ;
  const std::string& connection_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connection_key(Arg_&& arg, Args_... args);
  std::string* mutable_connection_key();
  PROTOBUF_NODISCARD std::string* release_connection_key();
  void set_allocated_connection_key(std::string* ptr);

  private:
  const std::string& _internal_connection_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_key(
      const std::string& value);
  std::string* _internal_mutable_connection_key();

  public:
  // optional string identity_local = 4;
  bool has_identity_local() const;
  void clear_identity_local() ;
  const std::string& identity_local() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity_local(Arg_&& arg, Args_... args);
  std::string* mutable_identity_local();
  PROTOBUF_NODISCARD std::string* release_identity_local();
  void set_allocated_identity_local(std::string* ptr);

  private:
  const std::string& _internal_identity_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_local(
      const std::string& value);
  std::string* _internal_mutable_identity_local();

  public:
  // optional string identity_remote = 5;
  bool has_identity_remote() const;
  void clear_identity_remote() ;
  const std::string& identity_remote() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identity_remote(Arg_&& arg, Args_... args);
  std::string* mutable_identity_remote();
  PROTOBUF_NODISCARD std::string* release_identity_remote();
  void set_allocated_identity_remote(std::string* ptr);

  private:
  const std::string& _internal_identity_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity_remote(
      const std::string& value);
  std::string* _internal_mutable_identity_remote();

  public:
  // optional string close_message = 15;
  bool has_close_message() const;
  void clear_close_message() ;
  const std::string& close_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_close_message(Arg_&& arg, Args_... args);
  std::string* mutable_close_message();
  PROTOBUF_NODISCARD std::string* release_close_message();
  void set_allocated_close_message(std::string* ptr);

  private:
  const std::string& _internal_close_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_close_message(
      const std::string& value);
  std::string* _internal_mutable_close_message();

  public:
  // optional string status_loc_token = 16;
  bool has_status_loc_token() const;
  void clear_status_loc_token() ;
  const std::string& status_loc_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status_loc_token(Arg_&& arg, Args_... args);
  std::string* mutable_status_loc_token();
  PROTOBUF_NODISCARD std::string* release_status_loc_token();
  void set_allocated_status_loc_token(std::string* ptr);

  private:
  const std::string& _internal_status_loc_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_loc_token(
      const std::string& value);
  std::string* _internal_mutable_status_loc_token();

  public:
  // optional string sdrpopid_local = 21;
  bool has_sdrpopid_local() const;
  void clear_sdrpopid_local() ;
  const std::string& sdrpopid_local() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdrpopid_local(Arg_&& arg, Args_... args);
  std::string* mutable_sdrpopid_local();
  PROTOBUF_NODISCARD std::string* release_sdrpopid_local();
  void set_allocated_sdrpopid_local(std::string* ptr);

  private:
  const std::string& _internal_sdrpopid_local() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpopid_local(
      const std::string& value);
  std::string* _internal_mutable_sdrpopid_local();

  public:
  // optional string sdrpopid_remote = 22;
  bool has_sdrpopid_remote() const;
  void clear_sdrpopid_remote() ;
  const std::string& sdrpopid_remote() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sdrpopid_remote(Arg_&& arg, Args_... args);
  std::string* mutable_sdrpopid_remote();
  PROTOBUF_NODISCARD std::string* release_sdrpopid_remote();
  void set_allocated_sdrpopid_remote(std::string* ptr);

  private:
  const std::string& _internal_sdrpopid_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdrpopid_remote(
      const std::string& value);
  std::string* _internal_mutable_sdrpopid_remote();

  public:
  // optional string address_remote = 23;
  bool has_address_remote() const;
  void clear_address_remote() ;
  const std::string& address_remote() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address_remote(Arg_&& arg, Args_... args);
  std::string* mutable_address_remote();
  PROTOBUF_NODISCARD std::string* release_address_remote();
  void set_allocated_address_remote(std::string* ptr);

  private:
  const std::string& _internal_address_remote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address_remote(
      const std::string& value);
  std::string* _internal_mutable_address_remote();

  public:
  // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24;
  bool has_p2p_routing() const;
  void clear_p2p_routing() ;
  const ::CMsgSteamDatagramP2PRoutingSummary& p2p_routing() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramP2PRoutingSummary* release_p2p_routing();
  ::CMsgSteamDatagramP2PRoutingSummary* mutable_p2p_routing();
  void set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* value);
  void unsafe_arena_set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* value);
  ::CMsgSteamDatagramP2PRoutingSummary* unsafe_arena_release_p2p_routing();

  private:
  const ::CMsgSteamDatagramP2PRoutingSummary& _internal_p2p_routing() const;
  ::CMsgSteamDatagramP2PRoutingSummary* _internal_mutable_p2p_routing();

  public:
  // optional .CMsgSteamDatagramConnectionQuality e2e_quality_local = 30;
  bool has_e2e_quality_local() const;
  void clear_e2e_quality_local() ;
  const ::CMsgSteamDatagramConnectionQuality& e2e_quality_local() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_e2e_quality_local();
  ::CMsgSteamDatagramConnectionQuality* mutable_e2e_quality_local();
  void set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* value);
  void unsafe_arena_set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* value);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_e2e_quality_local();

  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_e2e_quality_local() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_e2e_quality_local();

  public:
  // optional .CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31;
  bool has_e2e_quality_remote() const;
  void clear_e2e_quality_remote() ;
  const ::CMsgSteamDatagramConnectionQuality& e2e_quality_remote() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_e2e_quality_remote();
  ::CMsgSteamDatagramConnectionQuality* mutable_e2e_quality_remote();
  void set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* value);
  void unsafe_arena_set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* value);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_e2e_quality_remote();

  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_e2e_quality_remote() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_e2e_quality_remote();

  public:
  // optional .CMsgSteamDatagramConnectionQuality front_quality_local = 40;
  bool has_front_quality_local() const;
  void clear_front_quality_local() ;
  const ::CMsgSteamDatagramConnectionQuality& front_quality_local() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_front_quality_local();
  ::CMsgSteamDatagramConnectionQuality* mutable_front_quality_local();
  void set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* value);
  void unsafe_arena_set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* value);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_front_quality_local();

  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_front_quality_local() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_front_quality_local();

  public:
  // optional .CMsgSteamDatagramConnectionQuality front_quality_remote = 41;
  bool has_front_quality_remote() const;
  void clear_front_quality_remote() ;
  const ::CMsgSteamDatagramConnectionQuality& front_quality_remote() const;
  PROTOBUF_NODISCARD ::CMsgSteamDatagramConnectionQuality* release_front_quality_remote();
  ::CMsgSteamDatagramConnectionQuality* mutable_front_quality_remote();
  void set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* value);
  void unsafe_arena_set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* value);
  ::CMsgSteamDatagramConnectionQuality* unsafe_arena_release_front_quality_remote();

  private:
  const ::CMsgSteamDatagramConnectionQuality& _internal_front_quality_remote() const;
  ::CMsgSteamDatagramConnectionQuality* _internal_mutable_front_quality_remote();

  public:
  // optional uint32 appid = 2;
  bool has_appid() const;
  void clear_appid() ;
  ::uint32_t appid() const;
  void set_appid(::uint32_t value);

  private:
  ::uint32_t _internal_appid() const;
  void _internal_set_appid(::uint32_t value);

  public:
  // optional fixed32 connection_id_local = 3;
  bool has_connection_id_local() const;
  void clear_connection_id_local() ;
  ::uint32_t connection_id_local() const;
  void set_connection_id_local(::uint32_t value);

  private:
  ::uint32_t _internal_connection_id_local() const;
  void _internal_set_connection_id_local(::uint32_t value);

  public:
  // optional uint32 connection_state = 10;
  bool has_connection_state() const;
  void clear_connection_state() ;
  ::uint32_t connection_state() const;
  void set_connection_state(::uint32_t value);

  private:
  ::uint32_t _internal_connection_state() const;
  void _internal_set_connection_state(::uint32_t value);

  public:
  // optional uint32 start_time = 12;
  bool has_start_time() const;
  void clear_start_time() ;
  ::uint32_t start_time() const;
  void set_start_time(::uint32_t value);

  private:
  ::uint32_t _internal_start_time() const;
  void _internal_set_start_time(::uint32_t value);

  public:
  // optional uint32 close_time = 13;
  bool has_close_time() const;
  void clear_close_time() ;
  ::uint32_t close_time() const;
  void set_close_time(::uint32_t value);

  private:
  ::uint32_t _internal_close_time() const;
  void _internal_set_close_time(::uint32_t value);

  public:
  // optional uint32 close_reason = 14;
  bool has_close_reason() const;
  void clear_close_reason() ;
  ::uint32_t close_reason() const;
  void set_close_reason(::uint32_t value);

  private:
  ::uint32_t _internal_close_reason() const;
  void _internal_set_close_reason(::uint32_t value);

  public:
  // optional uint32 transport_kind = 20;
  bool has_transport_kind() const;
  void clear_transport_kind() ;
  ::uint32_t transport_kind() const;
  void set_transport_kind(::uint32_t value);

  private:
  ::uint32_t _internal_transport_kind() const;
  void _internal_set_transport_kind(::uint32_t value);

  public:
  // optional uint32 ping_interior = 25;
  bool has_ping_interior() const;
  void clear_ping_interior() ;
  ::uint32_t ping_interior() const;
  void set_ping_interior(::uint32_t value);

  private:
  ::uint32_t _internal_ping_interior() const;
  void _internal_set_ping_interior(::uint32_t value);

  public:
  // optional uint32 ping_remote_front = 26;
  bool has_ping_remote_front() const;
  void clear_ping_remote_front() ;
  ::uint32_t ping_remote_front() const;
  void set_ping_remote_front(::uint32_t value);

  private:
  ::uint32_t _internal_ping_remote_front() const;
  void _internal_set_ping_remote_front(::uint32_t value);

  public:
  // optional uint32 ping_default_internet_route = 27;
  bool has_ping_default_internet_route() const;
  void clear_ping_default_internet_route() ;
  ::uint32_t ping_default_internet_route() const;
  void set_ping_default_internet_route(::uint32_t value);

  private:
  ::uint32_t _internal_ping_default_internet_route() const;
  void _internal_set_ping_default_internet_route(::uint32_t value);

  public:
  // optional uint64 e2e_quality_remote_instantaneous_time = 32;
  bool has_e2e_quality_remote_instantaneous_time() const;
  void clear_e2e_quality_remote_instantaneous_time() ;
  ::uint64_t e2e_quality_remote_instantaneous_time() const;
  void set_e2e_quality_remote_instantaneous_time(::uint64_t value);

  private:
  ::uint64_t _internal_e2e_quality_remote_instantaneous_time() const;
  void _internal_set_e2e_quality_remote_instantaneous_time(::uint64_t value);

  public:
  // optional uint64 e2e_quality_remote_lifetime_time = 33;
  bool has_e2e_quality_remote_lifetime_time() const;
  void clear_e2e_quality_remote_lifetime_time() ;
  ::uint64_t e2e_quality_remote_lifetime_time() const;
  void set_e2e_quality_remote_lifetime_time(::uint64_t value);

  private:
  ::uint64_t _internal_e2e_quality_remote_lifetime_time() const;
  void _internal_set_e2e_quality_remote_lifetime_time(::uint64_t value);

  public:
  // optional uint64 front_quality_remote_instantaneous_time = 42;
  bool has_front_quality_remote_instantaneous_time() const;
  void clear_front_quality_remote_instantaneous_time() ;
  ::uint64_t front_quality_remote_instantaneous_time() const;
  void set_front_quality_remote_instantaneous_time(::uint64_t value);

  private:
  ::uint64_t _internal_front_quality_remote_instantaneous_time() const;
  void _internal_set_front_quality_remote_instantaneous_time(::uint64_t value);

  public:
  // optional uint64 front_quality_remote_lifetime_time = 43;
  bool has_front_quality_remote_lifetime_time() const;
  void clear_front_quality_remote_lifetime_time() ;
  ::uint64_t front_quality_remote_lifetime_time() const;
  void set_front_quality_remote_lifetime_time(::uint64_t value);

  private:
  ::uint64_t _internal_front_quality_remote_lifetime_time() const;
  void _internal_set_front_quality_remote_lifetime_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_ConnectionState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 27, 5, 181, 7> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr connection_key_;
    ::google::protobuf::internal::ArenaStringPtr identity_local_;
    ::google::protobuf::internal::ArenaStringPtr identity_remote_;
    ::google::protobuf::internal::ArenaStringPtr close_message_;
    ::google::protobuf::internal::ArenaStringPtr status_loc_token_;
    ::google::protobuf::internal::ArenaStringPtr sdrpopid_local_;
    ::google::protobuf::internal::ArenaStringPtr sdrpopid_remote_;
    ::google::protobuf::internal::ArenaStringPtr address_remote_;
    ::CMsgSteamDatagramP2PRoutingSummary* p2p_routing_;
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_local_;
    ::CMsgSteamDatagramConnectionQuality* e2e_quality_remote_;
    ::CMsgSteamDatagramConnectionQuality* front_quality_local_;
    ::CMsgSteamDatagramConnectionQuality* front_quality_remote_;
    ::uint32_t appid_;
    ::uint32_t connection_id_local_;
    ::uint32_t connection_state_;
    ::uint32_t start_time_;
    ::uint32_t close_time_;
    ::uint32_t close_reason_;
    ::uint32_t transport_kind_;
    ::uint32_t ping_interior_;
    ::uint32_t ping_remote_front_;
    ::uint32_t ping_default_internet_route_;
    ::uint64_t e2e_quality_remote_instantaneous_time_;
    ::uint64_t e2e_quality_remote_lifetime_time_;
    ::uint64_t front_quality_remote_instantaneous_time_;
    ::uint64_t front_quality_remote_lifetime_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};// -------------------------------------------------------------------

class CGameNetworkingUI_Message final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CGameNetworkingUI_Message) */ {
 public:
  inline CGameNetworkingUI_Message() : CGameNetworkingUI_Message(nullptr) {}
  ~CGameNetworkingUI_Message() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CGameNetworkingUI_Message(::google::protobuf::internal::ConstantInitialized);

  CGameNetworkingUI_Message(const CGameNetworkingUI_Message& from);
  CGameNetworkingUI_Message(CGameNetworkingUI_Message&& from) noexcept
    : CGameNetworkingUI_Message() {
    *this = ::std::move(from);
  }

  inline CGameNetworkingUI_Message& operator=(const CGameNetworkingUI_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGameNetworkingUI_Message& operator=(CGameNetworkingUI_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGameNetworkingUI_Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGameNetworkingUI_Message* internal_default_instance() {
    return reinterpret_cast<const CGameNetworkingUI_Message*>(
               &_CGameNetworkingUI_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CGameNetworkingUI_Message& a, CGameNetworkingUI_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(CGameNetworkingUI_Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGameNetworkingUI_Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGameNetworkingUI_Message* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGameNetworkingUI_Message>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CGameNetworkingUI_Message& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CGameNetworkingUI_Message& from) {
    CGameNetworkingUI_Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGameNetworkingUI_Message* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CGameNetworkingUI_Message";
  }
  protected:
  explicit CGameNetworkingUI_Message(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionStateFieldNumber = 1,
  };
  // repeated .CGameNetworkingUI_ConnectionState connection_state = 1;
  int connection_state_size() const;
  private:
  int _internal_connection_state_size() const;

  public:
  void clear_connection_state() ;
  ::CGameNetworkingUI_ConnectionState* mutable_connection_state(int index);
  ::google::protobuf::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >*
      mutable_connection_state();
  private:
  const ::google::protobuf::RepeatedPtrField<::CGameNetworkingUI_ConnectionState>& _internal_connection_state() const;
  ::google::protobuf::RepeatedPtrField<::CGameNetworkingUI_ConnectionState>* _internal_mutable_connection_state();
  public:
  const ::CGameNetworkingUI_ConnectionState& connection_state(int index) const;
  ::CGameNetworkingUI_ConnectionState* add_connection_state();
  const ::google::protobuf::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >&
      connection_state() const;
  // @@protoc_insertion_point(class_scope:CGameNetworkingUI_Message)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState > connection_state_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_steammessages_5fgamenetworkingui_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CGameNetworkingUI_GlobalState

// -------------------------------------------------------------------

// CGameNetworkingUI_ConnectionState

// optional string connection_key = 1;
inline bool CGameNetworkingUI_ConnectionState::has_connection_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_key() {
  _impl_.connection_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::connection_key() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_key)
  return _internal_connection_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_connection_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.connection_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_key)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_connection_key() {
  std::string* _s = _internal_mutable_connection_key();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.connection_key)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_connection_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connection_key_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.connection_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_connection_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.connection_key_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_connection_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.connection_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.connection_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connection_key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_connection_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.connection_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connection_key_.IsDefault()) {
          _impl_.connection_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.connection_key)
}

// optional uint32 appid = 2;
inline bool CGameNetworkingUI_ConnectionState::has_appid() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_appid() {
  _impl_.appid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::appid() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.appid)
  return _internal_appid();
}
inline void CGameNetworkingUI_ConnectionState::set_appid(::uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.appid)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_appid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.appid_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_appid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.appid_ = value;
}

// optional fixed32 connection_id_local = 3;
inline bool CGameNetworkingUI_ConnectionState::has_connection_id_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_id_local() {
  _impl_.connection_id_local_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::connection_id_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_id_local)
  return _internal_connection_id_local();
}
inline void CGameNetworkingUI_ConnectionState::set_connection_id_local(::uint32_t value) {
  _internal_set_connection_id_local(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_id_local)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_connection_id_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connection_id_local_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_id_local(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.connection_id_local_ = value;
}

// optional string identity_local = 4;
inline bool CGameNetworkingUI_ConnectionState::has_identity_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_identity_local() {
  _impl_.identity_local_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::identity_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.identity_local)
  return _internal_identity_local();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_identity_local(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.identity_local_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.identity_local)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_identity_local() {
  std::string* _s = _internal_mutable_identity_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.identity_local)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_identity_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.identity_local_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_identity_local(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.identity_local_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_identity_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.identity_local_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_identity_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.identity_local)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.identity_local_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.identity_local_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_identity_local(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.identity_local_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identity_local_.IsDefault()) {
          _impl_.identity_local_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.identity_local)
}

// optional string identity_remote = 5;
inline bool CGameNetworkingUI_ConnectionState::has_identity_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_identity_remote() {
  _impl_.identity_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::identity_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.identity_remote)
  return _internal_identity_remote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_identity_remote(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.identity_remote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.identity_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_identity_remote() {
  std::string* _s = _internal_mutable_identity_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.identity_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_identity_remote() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.identity_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_identity_remote(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.identity_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_identity_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.identity_remote_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_identity_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.identity_remote)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.identity_remote_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.identity_remote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_identity_remote(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.identity_remote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identity_remote_.IsDefault()) {
          _impl_.identity_remote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.identity_remote)
}

// optional uint32 connection_state = 10;
inline bool CGameNetworkingUI_ConnectionState::has_connection_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_connection_state() {
  _impl_.connection_state_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::connection_state() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.connection_state)
  return _internal_connection_state();
}
inline void CGameNetworkingUI_ConnectionState::set_connection_state(::uint32_t value) {
  _internal_set_connection_state(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.connection_state)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_connection_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connection_state_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_connection_state(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.connection_state_ = value;
}

// optional uint32 start_time = 12;
inline bool CGameNetworkingUI_ConnectionState::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_start_time() {
  _impl_.start_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::start_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.start_time)
  return _internal_start_time();
}
inline void CGameNetworkingUI_ConnectionState::set_start_time(::uint32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.start_time)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_start_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_start_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.start_time_ = value;
}

// optional uint32 close_time = 13;
inline bool CGameNetworkingUI_ConnectionState::has_close_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_close_time() {
  _impl_.close_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::close_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_time)
  return _internal_close_time();
}
inline void CGameNetworkingUI_ConnectionState::set_close_time(::uint32_t value) {
  _internal_set_close_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_time)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_close_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.close_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.close_time_ = value;
}

// optional uint32 close_reason = 14;
inline bool CGameNetworkingUI_ConnectionState::has_close_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_close_reason() {
  _impl_.close_reason_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::close_reason() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_reason)
  return _internal_close_reason();
}
inline void CGameNetworkingUI_ConnectionState::set_close_reason(::uint32_t value) {
  _internal_set_close_reason(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_reason)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_close_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.close_reason_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_reason(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.close_reason_ = value;
}

// optional string close_message = 15;
inline bool CGameNetworkingUI_ConnectionState::has_close_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_close_message() {
  _impl_.close_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::close_message() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.close_message)
  return _internal_close_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_close_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.close_message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.close_message)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_close_message() {
  std::string* _s = _internal_mutable_close_message();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.close_message)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_close_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.close_message_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_close_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.close_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_close_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.close_message_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_close_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.close_message)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.close_message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.close_message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_close_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.close_message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.close_message_.IsDefault()) {
          _impl_.close_message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.close_message)
}

// optional string status_loc_token = 16;
inline bool CGameNetworkingUI_ConnectionState::has_status_loc_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_status_loc_token() {
  _impl_.status_loc_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::status_loc_token() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.status_loc_token)
  return _internal_status_loc_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_status_loc_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_loc_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.status_loc_token)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_status_loc_token() {
  std::string* _s = _internal_mutable_status_loc_token();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.status_loc_token)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_status_loc_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_loc_token_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_status_loc_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.status_loc_token_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_status_loc_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.status_loc_token_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_status_loc_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.status_loc_token)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.status_loc_token_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_loc_token_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_status_loc_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.status_loc_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_loc_token_.IsDefault()) {
          _impl_.status_loc_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.status_loc_token)
}

// optional uint32 transport_kind = 20;
inline bool CGameNetworkingUI_ConnectionState::has_transport_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_transport_kind() {
  _impl_.transport_kind_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::transport_kind() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.transport_kind)
  return _internal_transport_kind();
}
inline void CGameNetworkingUI_ConnectionState::set_transport_kind(::uint32_t value) {
  _internal_set_transport_kind(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.transport_kind)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_transport_kind() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_kind_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_transport_kind(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.transport_kind_ = value;
}

// optional string sdrpopid_local = 21;
inline bool CGameNetworkingUI_ConnectionState::has_sdrpopid_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_sdrpopid_local() {
  _impl_.sdrpopid_local_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::sdrpopid_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  return _internal_sdrpopid_local();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_sdrpopid_local(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sdrpopid_local_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.sdrpopid_local)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_sdrpopid_local() {
  std::string* _s = _internal_mutable_sdrpopid_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_sdrpopid_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdrpopid_local_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_sdrpopid_local(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sdrpopid_local_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_sdrpopid_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sdrpopid_local_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_sdrpopid_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.sdrpopid_local)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.sdrpopid_local_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sdrpopid_local_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_sdrpopid_local(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sdrpopid_local_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdrpopid_local_.IsDefault()) {
          _impl_.sdrpopid_local_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.sdrpopid_local)
}

// optional string sdrpopid_remote = 22;
inline bool CGameNetworkingUI_ConnectionState::has_sdrpopid_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_sdrpopid_remote() {
  _impl_.sdrpopid_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::sdrpopid_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  return _internal_sdrpopid_remote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_sdrpopid_remote(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sdrpopid_remote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_sdrpopid_remote() {
  std::string* _s = _internal_mutable_sdrpopid_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_sdrpopid_remote() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdrpopid_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_sdrpopid_remote(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.sdrpopid_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_sdrpopid_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.sdrpopid_remote_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_sdrpopid_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.sdrpopid_remote_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sdrpopid_remote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_sdrpopid_remote(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.sdrpopid_remote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sdrpopid_remote_.IsDefault()) {
          _impl_.sdrpopid_remote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
}

// optional string address_remote = 23;
inline bool CGameNetworkingUI_ConnectionState::has_address_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_address_remote() {
  _impl_.address_remote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CGameNetworkingUI_ConnectionState::address_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.address_remote)
  return _internal_address_remote();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CGameNetworkingUI_ConnectionState::set_address_remote(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.address_remote_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.address_remote)
}
inline std::string* CGameNetworkingUI_ConnectionState::mutable_address_remote() {
  std::string* _s = _internal_mutable_address_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.address_remote)
  return _s;
}
inline const std::string& CGameNetworkingUI_ConnectionState::_internal_address_remote() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_remote_.Get();
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_address_remote(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.address_remote_.Set(value, GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::_internal_mutable_address_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.address_remote_.Mutable( GetArenaForAllocation());
}
inline std::string* CGameNetworkingUI_ConnectionState::release_address_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.address_remote)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.address_remote_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_remote_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_address_remote(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.address_remote_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_remote_.IsDefault()) {
          _impl_.address_remote_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.address_remote)
}

// optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing = 24;
inline bool CGameNetworkingUI_ConnectionState::has_p2p_routing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.p2p_routing_ != nullptr);
  return value;
}
inline const ::CMsgSteamDatagramP2PRoutingSummary& CGameNetworkingUI_ConnectionState::_internal_p2p_routing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgSteamDatagramP2PRoutingSummary* p = _impl_.p2p_routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramP2PRoutingSummary&>(::_CMsgSteamDatagramP2PRoutingSummary_default_instance_);
}
inline const ::CMsgSteamDatagramP2PRoutingSummary& CGameNetworkingUI_ConnectionState::p2p_routing() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.p2p_routing)
  return _internal_p2p_routing();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.p2p_routing_);
  }
  _impl_.p2p_routing_ = reinterpret_cast<::CMsgSteamDatagramP2PRoutingSummary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.p2p_routing)
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::release_p2p_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgSteamDatagramP2PRoutingSummary* released = _impl_.p2p_routing_;
  _impl_.p2p_routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::unsafe_arena_release_p2p_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.p2p_routing)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::CMsgSteamDatagramP2PRoutingSummary* temp = _impl_.p2p_routing_;
  _impl_.p2p_routing_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::_internal_mutable_p2p_routing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.p2p_routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramP2PRoutingSummary>(GetArenaForAllocation());
    _impl_.p2p_routing_ = reinterpret_cast<::CMsgSteamDatagramP2PRoutingSummary*>(p);
  }
  return _impl_.p2p_routing_;
}
inline ::CMsgSteamDatagramP2PRoutingSummary* CGameNetworkingUI_ConnectionState::mutable_p2p_routing() {
  ::CMsgSteamDatagramP2PRoutingSummary* _msg = _internal_mutable_p2p_routing();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.p2p_routing)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_p2p_routing(::CMsgSteamDatagramP2PRoutingSummary* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.p2p_routing_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.p2p_routing_ = reinterpret_cast<::CMsgSteamDatagramP2PRoutingSummary*>(value);
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.p2p_routing)
}

// optional uint32 ping_interior = 25;
inline bool CGameNetworkingUI_ConnectionState::has_ping_interior() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_interior() {
  _impl_.ping_interior_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::ping_interior() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_interior)
  return _internal_ping_interior();
}
inline void CGameNetworkingUI_ConnectionState::set_ping_interior(::uint32_t value) {
  _internal_set_ping_interior(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_interior)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_interior() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ping_interior_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_interior(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.ping_interior_ = value;
}

// optional uint32 ping_remote_front = 26;
inline bool CGameNetworkingUI_ConnectionState::has_ping_remote_front() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_remote_front() {
  _impl_.ping_remote_front_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::ping_remote_front() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_remote_front)
  return _internal_ping_remote_front();
}
inline void CGameNetworkingUI_ConnectionState::set_ping_remote_front(::uint32_t value) {
  _internal_set_ping_remote_front(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_remote_front)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_remote_front() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ping_remote_front_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_remote_front(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.ping_remote_front_ = value;
}

// optional uint32 ping_default_internet_route = 27;
inline bool CGameNetworkingUI_ConnectionState::has_ping_default_internet_route() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_ping_default_internet_route() {
  _impl_.ping_default_internet_route_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::ping_default_internet_route() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
  return _internal_ping_default_internet_route();
}
inline void CGameNetworkingUI_ConnectionState::set_ping_default_internet_route(::uint32_t value) {
  _internal_set_ping_default_internet_route(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
}
inline ::uint32_t CGameNetworkingUI_ConnectionState::_internal_ping_default_internet_route() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ping_default_internet_route_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_ping_default_internet_route(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.ping_default_internet_route_ = value;
}

// optional .CMsgSteamDatagramConnectionQuality e2e_quality_local = 30;
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e2e_quality_local_ != nullptr);
  return value;
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_e2e_quality_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.e2e_quality_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::e2e_quality_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_local)
  return _internal_e2e_quality_local();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.e2e_quality_local_);
  }
  _impl_.e2e_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_local)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_e2e_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgSteamDatagramConnectionQuality* released = _impl_.e2e_quality_local_;
  _impl_.e2e_quality_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_e2e_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.e2e_quality_local)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_local_;
  _impl_.e2e_quality_local_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_e2e_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.e2e_quality_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.e2e_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(p);
  }
  return _impl_.e2e_quality_local_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_e2e_quality_local() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_e2e_quality_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.e2e_quality_local)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_e2e_quality_local(::CMsgSteamDatagramConnectionQuality* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.e2e_quality_local_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.e2e_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_local)
}

// optional .CMsgSteamDatagramConnectionQuality e2e_quality_remote = 31;
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e2e_quality_remote_ != nullptr);
  return value;
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.e2e_quality_remote_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::e2e_quality_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
  return _internal_e2e_quality_remote();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.e2e_quality_remote_);
  }
  _impl_.e2e_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_e2e_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::CMsgSteamDatagramConnectionQuality* released = _impl_.e2e_quality_remote_;
  _impl_.e2e_quality_remote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_e2e_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.e2e_quality_remote)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.e2e_quality_remote_;
  _impl_.e2e_quality_remote_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_e2e_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.e2e_quality_remote_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.e2e_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(p);
  }
  return _impl_.e2e_quality_remote_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_e2e_quality_remote() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_e2e_quality_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_e2e_quality_remote(::CMsgSteamDatagramConnectionQuality* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.e2e_quality_remote_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.e2e_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
}

// optional uint64 e2e_quality_remote_instantaneous_time = 32;
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote_instantaneous_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_e2e_quality_remote_instantaneous_time() {
  _impl_.e2e_quality_remote_instantaneous_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::e2e_quality_remote_instantaneous_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
  return _internal_e2e_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::set_e2e_quality_remote_instantaneous_time(::uint64_t value) {
  _internal_set_e2e_quality_remote_instantaneous_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote_instantaneous_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e2e_quality_remote_instantaneous_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_e2e_quality_remote_instantaneous_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.e2e_quality_remote_instantaneous_time_ = value;
}

// optional uint64 e2e_quality_remote_lifetime_time = 33;
inline bool CGameNetworkingUI_ConnectionState::has_e2e_quality_remote_lifetime_time() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_e2e_quality_remote_lifetime_time() {
  _impl_.e2e_quality_remote_lifetime_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::e2e_quality_remote_lifetime_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
  return _internal_e2e_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::set_e2e_quality_remote_lifetime_time(::uint64_t value) {
  _internal_set_e2e_quality_remote_lifetime_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::_internal_e2e_quality_remote_lifetime_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e2e_quality_remote_lifetime_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_e2e_quality_remote_lifetime_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.e2e_quality_remote_lifetime_time_ = value;
}

// optional .CMsgSteamDatagramConnectionQuality front_quality_local = 40;
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_local() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front_quality_local_ != nullptr);
  return value;
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_front_quality_local() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.front_quality_local_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::front_quality_local() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_local)
  return _internal_front_quality_local();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.front_quality_local_);
  }
  _impl_.front_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_local)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_front_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::CMsgSteamDatagramConnectionQuality* released = _impl_.front_quality_local_;
  _impl_.front_quality_local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_front_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.front_quality_local)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_local_;
  _impl_.front_quality_local_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_front_quality_local() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.front_quality_local_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.front_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(p);
  }
  return _impl_.front_quality_local_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_front_quality_local() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_front_quality_local();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.front_quality_local)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_front_quality_local(::CMsgSteamDatagramConnectionQuality* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.front_quality_local_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.front_quality_local_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_local)
}

// optional .CMsgSteamDatagramConnectionQuality front_quality_remote = 41;
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.front_quality_remote_ != nullptr);
  return value;
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::_internal_front_quality_remote() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgSteamDatagramConnectionQuality* p = _impl_.front_quality_remote_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgSteamDatagramConnectionQuality&>(::_CMsgSteamDatagramConnectionQuality_default_instance_);
}
inline const ::CMsgSteamDatagramConnectionQuality& CGameNetworkingUI_ConnectionState::front_quality_remote() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote)
  return _internal_front_quality_remote();
}
inline void CGameNetworkingUI_ConnectionState::unsafe_arena_set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.front_quality_remote_);
  }
  _impl_.front_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_remote)
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::release_front_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::CMsgSteamDatagramConnectionQuality* released = _impl_.front_quality_remote_;
  _impl_.front_quality_remote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::unsafe_arena_release_front_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CGameNetworkingUI_ConnectionState.front_quality_remote)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::CMsgSteamDatagramConnectionQuality* temp = _impl_.front_quality_remote_;
  _impl_.front_quality_remote_ = nullptr;
  return temp;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::_internal_mutable_front_quality_remote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.front_quality_remote_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgSteamDatagramConnectionQuality>(GetArenaForAllocation());
    _impl_.front_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(p);
  }
  return _impl_.front_quality_remote_;
}
inline ::CMsgSteamDatagramConnectionQuality* CGameNetworkingUI_ConnectionState::mutable_front_quality_remote() {
  ::CMsgSteamDatagramConnectionQuality* _msg = _internal_mutable_front_quality_remote();
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_ConnectionState.front_quality_remote)
  return _msg;
}
inline void CGameNetworkingUI_ConnectionState::set_allocated_front_quality_remote(::CMsgSteamDatagramConnectionQuality* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.front_quality_remote_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.front_quality_remote_ = reinterpret_cast<::CMsgSteamDatagramConnectionQuality*>(value);
  // @@protoc_insertion_point(field_set_allocated:CGameNetworkingUI_ConnectionState.front_quality_remote)
}

// optional uint64 front_quality_remote_instantaneous_time = 42;
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote_instantaneous_time() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_front_quality_remote_instantaneous_time() {
  _impl_.front_quality_remote_instantaneous_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::front_quality_remote_instantaneous_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
  return _internal_front_quality_remote_instantaneous_time();
}
inline void CGameNetworkingUI_ConnectionState::set_front_quality_remote_instantaneous_time(::uint64_t value) {
  _internal_set_front_quality_remote_instantaneous_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::_internal_front_quality_remote_instantaneous_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.front_quality_remote_instantaneous_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_front_quality_remote_instantaneous_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.front_quality_remote_instantaneous_time_ = value;
}

// optional uint64 front_quality_remote_lifetime_time = 43;
inline bool CGameNetworkingUI_ConnectionState::has_front_quality_remote_lifetime_time() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void CGameNetworkingUI_ConnectionState::clear_front_quality_remote_lifetime_time() {
  _impl_.front_quality_remote_lifetime_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::front_quality_remote_lifetime_time() const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
  return _internal_front_quality_remote_lifetime_time();
}
inline void CGameNetworkingUI_ConnectionState::set_front_quality_remote_lifetime_time(::uint64_t value) {
  _internal_set_front_quality_remote_lifetime_time(value);
  // @@protoc_insertion_point(field_set:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
}
inline ::uint64_t CGameNetworkingUI_ConnectionState::_internal_front_quality_remote_lifetime_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.front_quality_remote_lifetime_time_;
}
inline void CGameNetworkingUI_ConnectionState::_internal_set_front_quality_remote_lifetime_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.front_quality_remote_lifetime_time_ = value;
}

// -------------------------------------------------------------------

// CGameNetworkingUI_Message

// repeated .CGameNetworkingUI_ConnectionState connection_state = 1;
inline int CGameNetworkingUI_Message::_internal_connection_state_size() const {
  return _internal_connection_state().size();
}
inline int CGameNetworkingUI_Message::connection_state_size() const {
  return _internal_connection_state_size();
}
inline void CGameNetworkingUI_Message::clear_connection_state() {
  _internal_mutable_connection_state()->Clear();
}
inline ::CGameNetworkingUI_ConnectionState* CGameNetworkingUI_Message::mutable_connection_state(int index) {
  // @@protoc_insertion_point(field_mutable:CGameNetworkingUI_Message.connection_state)
  return _internal_mutable_connection_state()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >*
CGameNetworkingUI_Message::mutable_connection_state() {
  // @@protoc_insertion_point(field_mutable_list:CGameNetworkingUI_Message.connection_state)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_connection_state();
}
inline const ::CGameNetworkingUI_ConnectionState& CGameNetworkingUI_Message::connection_state(int index) const {
  // @@protoc_insertion_point(field_get:CGameNetworkingUI_Message.connection_state)
    return _internal_connection_state().Get(index);
}
inline ::CGameNetworkingUI_ConnectionState* CGameNetworkingUI_Message::add_connection_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CGameNetworkingUI_ConnectionState* _add = _internal_mutable_connection_state()->Add();
  // @@protoc_insertion_point(field_add:CGameNetworkingUI_Message.connection_state)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::CGameNetworkingUI_ConnectionState >&
CGameNetworkingUI_Message::connection_state() const {
  // @@protoc_insertion_point(field_list:CGameNetworkingUI_Message.connection_state)
  return _internal_connection_state();
}
inline const ::google::protobuf::RepeatedPtrField<::CGameNetworkingUI_ConnectionState>&
CGameNetworkingUI_Message::_internal_connection_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connection_state_;
}
inline ::google::protobuf::RepeatedPtrField<::CGameNetworkingUI_ConnectionState>*
CGameNetworkingUI_Message::_internal_mutable_connection_state() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.connection_state_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_steammessages_5fgamenetworkingui_2eproto_2epb_2eh
