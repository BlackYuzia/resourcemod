// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#include "te.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEArmorRicochet::CMsgTEArmorRicochet(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.pos_)*/ nullptr,
      /*decltype(_impl_.dir_)*/ nullptr,
    } {}
struct CMsgTEArmorRicochetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEArmorRicochetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEArmorRicochetDefaultTypeInternal() {}
  union {
    CMsgTEArmorRicochet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEArmorRicochetDefaultTypeInternal _CMsgTEArmorRicochet_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBaseBeam::CMsgTEBaseBeam(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.modelindex_)*/ ::uint64_t{0u},
      /*decltype(_impl_.haloindex_)*/ ::uint64_t{0u},
      /*decltype(_impl_.startframe_)*/ 0u,
      /*decltype(_impl_.framerate_)*/ 0u,
      /*decltype(_impl_.life_)*/ 0,
      /*decltype(_impl_.width_)*/ 0,
      /*decltype(_impl_.endwidth_)*/ 0,
      /*decltype(_impl_.fadelength_)*/ 0u,
      /*decltype(_impl_.amplitude_)*/ 0,
      /*decltype(_impl_.color_)*/ 0u,
      /*decltype(_impl_.speed_)*/ 0u,
      /*decltype(_impl_.flags_)*/ 0u,
    } {}
struct CMsgTEBaseBeamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBaseBeamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBaseBeamDefaultTypeInternal() {}
  union {
    CMsgTEBaseBeam _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBaseBeamDefaultTypeInternal _CMsgTEBaseBeam_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.base_)*/ nullptr,
      /*decltype(_impl_.start_)*/ nullptr,
      /*decltype(_impl_.end_)*/ nullptr,
      /*decltype(_impl_.startentity_)*/ 0u,
      /*decltype(_impl_.endentity_)*/ 0u,
    } {}
struct CMsgTEBeamEntPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamEntPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamEntPointDefaultTypeInternal() {}
  union {
    CMsgTEBeamEntPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamEntPointDefaultTypeInternal _CMsgTEBeamEntPoint_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBeamEnts::CMsgTEBeamEnts(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.base_)*/ nullptr,
      /*decltype(_impl_.startentity_)*/ 0u,
      /*decltype(_impl_.endentity_)*/ 0u,
    } {}
struct CMsgTEBeamEntsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamEntsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamEntsDefaultTypeInternal() {}
  union {
    CMsgTEBeamEnts _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamEntsDefaultTypeInternal _CMsgTEBeamEnts_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBeamPoints::CMsgTEBeamPoints(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.base_)*/ nullptr,
      /*decltype(_impl_.start_)*/ nullptr,
      /*decltype(_impl_.end_)*/ nullptr,
    } {}
struct CMsgTEBeamPointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamPointsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamPointsDefaultTypeInternal() {}
  union {
    CMsgTEBeamPoints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamPointsDefaultTypeInternal _CMsgTEBeamPoints_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBeamRing::CMsgTEBeamRing(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.base_)*/ nullptr,
      /*decltype(_impl_.startentity_)*/ 0u,
      /*decltype(_impl_.endentity_)*/ 0u,
    } {}
struct CMsgTEBeamRingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamRingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamRingDefaultTypeInternal() {}
  union {
    CMsgTEBeamRing _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamRingDefaultTypeInternal _CMsgTEBeamRing_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBSPDecal::CMsgTEBSPDecal(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.normal_)*/ nullptr,
      /*decltype(_impl_.saxis_)*/ nullptr,
      /*decltype(_impl_.index_)*/ 0u,
      /*decltype(_impl_.entity_)*/ -1,
    } {}
struct CMsgTEBSPDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBSPDecalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBSPDecalDefaultTypeInternal() {}
  union {
    CMsgTEBSPDecal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBSPDecalDefaultTypeInternal _CMsgTEBSPDecal_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBubbles::CMsgTEBubbles(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.mins_)*/ nullptr,
      /*decltype(_impl_.maxs_)*/ nullptr,
      /*decltype(_impl_.height_)*/ 0,
      /*decltype(_impl_.count_)*/ 0u,
      /*decltype(_impl_.speed_)*/ 0,
    } {}
struct CMsgTEBubblesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBubblesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBubblesDefaultTypeInternal() {}
  union {
    CMsgTEBubbles _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBubblesDefaultTypeInternal _CMsgTEBubbles_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBubbleTrail::CMsgTEBubbleTrail(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.mins_)*/ nullptr,
      /*decltype(_impl_.maxs_)*/ nullptr,
      /*decltype(_impl_.waterz_)*/ 0,
      /*decltype(_impl_.count_)*/ 0u,
      /*decltype(_impl_.speed_)*/ 0,
    } {}
struct CMsgTEBubbleTrailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBubbleTrailDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBubbleTrailDefaultTypeInternal() {}
  union {
    CMsgTEBubbleTrail _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBubbleTrailDefaultTypeInternal _CMsgTEBubbleTrail_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEDecal::CMsgTEDecal(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.start_)*/ nullptr,
      /*decltype(_impl_.hitbox_)*/ 0u,
      /*decltype(_impl_.index_)*/ 0u,
      /*decltype(_impl_.entity_)*/ -1,
    } {}
struct CMsgTEDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEDecalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEDecalDefaultTypeInternal() {}
  union {
    CMsgTEDecal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEDecalDefaultTypeInternal _CMsgTEDecal_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgEffectData::CMsgEffectData(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.start_)*/ nullptr,
      /*decltype(_impl_.normal_)*/ nullptr,
      /*decltype(_impl_.angles_)*/ nullptr,
      /*decltype(_impl_.scale_)*/ 0,
      /*decltype(_impl_.magnitude_)*/ 0,
      /*decltype(_impl_.radius_)*/ 0,
      /*decltype(_impl_.surfaceprop_)*/ 0u,
      /*decltype(_impl_.effectindex_)*/ ::uint64_t{0u},
      /*decltype(_impl_.damagetype_)*/ 0u,
      /*decltype(_impl_.material_)*/ 0u,
      /*decltype(_impl_.hitbox_)*/ 0u,
      /*decltype(_impl_.color_)*/ 0u,
      /*decltype(_impl_.flags_)*/ 0u,
      /*decltype(_impl_.attachmentindex_)*/ 0,
      /*decltype(_impl_.effectname_)*/ 0u,
      /*decltype(_impl_.attachmentname_)*/ 0u,
      /*decltype(_impl_.entity_)*/ 16777215u,
      /*decltype(_impl_.otherentity_)*/ 16777215u,
    } {}
struct CMsgEffectDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgEffectDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgEffectDataDefaultTypeInternal() {}
  union {
    CMsgEffectData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgEffectDataDefaultTypeInternal _CMsgEffectData_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEEffectDispatch::CMsgTEEffectDispatch(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.effectdata_)*/ nullptr,
    } {}
struct CMsgTEEffectDispatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEEffectDispatchDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEEffectDispatchDefaultTypeInternal() {}
  union {
    CMsgTEEffectDispatch _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEEffectDispatchDefaultTypeInternal _CMsgTEEffectDispatch_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEEnergySplash::CMsgTEEnergySplash(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.pos_)*/ nullptr,
      /*decltype(_impl_.dir_)*/ nullptr,
      /*decltype(_impl_.explosive_)*/ false,
    } {}
struct CMsgTEEnergySplashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEEnergySplashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEEnergySplashDefaultTypeInternal() {}
  union {
    CMsgTEEnergySplash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEEnergySplashDefaultTypeInternal _CMsgTEEnergySplash_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEFizz::CMsgTEFizz(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.density_)*/ 0u,
      /*decltype(_impl_.current_)*/ 0,
      /*decltype(_impl_.entity_)*/ -1,
    } {}
struct CMsgTEFizzDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEFizzDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEFizzDefaultTypeInternal() {}
  union {
    CMsgTEFizz _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEFizzDefaultTypeInternal _CMsgTEFizz_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEShatterSurface::CMsgTEShatterSurface(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.angles_)*/ nullptr,
      /*decltype(_impl_.force_)*/ nullptr,
      /*decltype(_impl_.forcepos_)*/ nullptr,
      /*decltype(_impl_.width_)*/ 0,
      /*decltype(_impl_.height_)*/ 0,
      /*decltype(_impl_.shardsize_)*/ 0,
      /*decltype(_impl_.surfacetype_)*/ 0u,
      /*decltype(_impl_.frontcolor_)*/ 0u,
      /*decltype(_impl_.backcolor_)*/ 0u,
    } {}
struct CMsgTEShatterSurfaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEShatterSurfaceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEShatterSurfaceDefaultTypeInternal() {}
  union {
    CMsgTEShatterSurface _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEShatterSurfaceDefaultTypeInternal _CMsgTEShatterSurface_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEGlowSprite::CMsgTEGlowSprite(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.scale_)*/ 0,
      /*decltype(_impl_.life_)*/ 0,
      /*decltype(_impl_.brightness_)*/ 0u,
    } {}
struct CMsgTEGlowSpriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEGlowSpriteDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEGlowSpriteDefaultTypeInternal() {}
  union {
    CMsgTEGlowSprite _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEGlowSpriteDefaultTypeInternal _CMsgTEGlowSprite_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEImpact::CMsgTEImpact(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.normal_)*/ nullptr,
      /*decltype(_impl_.type_)*/ 0u,
    } {}
struct CMsgTEImpactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEImpactDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEImpactDefaultTypeInternal() {}
  union {
    CMsgTEImpact _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEImpactDefaultTypeInternal _CMsgTEImpact_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.angles_)*/ nullptr,
      /*decltype(_impl_.scale_)*/ 0,
      /*decltype(_impl_.type_)*/ 0u,
    } {}
struct CMsgTEMuzzleFlashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEMuzzleFlashDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEMuzzleFlashDefaultTypeInternal() {}
  union {
    CMsgTEMuzzleFlash _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEMuzzleFlashDefaultTypeInternal _CMsgTEMuzzleFlash_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEBloodStream::CMsgTEBloodStream(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.direction_)*/ nullptr,
      /*decltype(_impl_.color_)*/ 0u,
      /*decltype(_impl_.amount_)*/ 0u,
    } {}
struct CMsgTEBloodStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBloodStreamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBloodStreamDefaultTypeInternal() {}
  union {
    CMsgTEBloodStream _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBloodStreamDefaultTypeInternal _CMsgTEBloodStream_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEExplosion::CMsgTEExplosion(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.effect_name_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.normal_)*/ nullptr,
      /*decltype(_impl_.framerate_)*/ 0u,
      /*decltype(_impl_.flags_)*/ 0u,
      /*decltype(_impl_.materialtype_)*/ 0u,
      /*decltype(_impl_.radius_)*/ 0u,
      /*decltype(_impl_.magnitude_)*/ 0u,
      /*decltype(_impl_.scale_)*/ 0,
      /*decltype(_impl_.affect_ragdolls_)*/ false,
      /*decltype(_impl_.explosion_type_)*/ 0u,
    } {}
struct CMsgTEExplosionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEExplosionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEExplosionDefaultTypeInternal() {}
  union {
    CMsgTEExplosion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEExplosionDefaultTypeInternal _CMsgTEExplosion_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEDust::CMsgTEDust(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.direction_)*/ nullptr,
      /*decltype(_impl_.size_)*/ 0,
      /*decltype(_impl_.speed_)*/ 0,
    } {}
struct CMsgTEDustDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEDustDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEDustDefaultTypeInternal() {}
  union {
    CMsgTEDust _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEDustDefaultTypeInternal _CMsgTEDust_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTELargeFunnel::CMsgTELargeFunnel(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.reversed_)*/ 0u,
    } {}
struct CMsgTELargeFunnelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTELargeFunnelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTELargeFunnelDefaultTypeInternal() {}
  union {
    CMsgTELargeFunnel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTELargeFunnelDefaultTypeInternal _CMsgTELargeFunnel_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTESparks::CMsgTESparks(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.direction_)*/ nullptr,
      /*decltype(_impl_.magnitude_)*/ 0u,
      /*decltype(_impl_.length_)*/ 0u,
    } {}
struct CMsgTESparksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTESparksDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTESparksDefaultTypeInternal() {}
  union {
    CMsgTESparks _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTESparksDefaultTypeInternal _CMsgTESparks_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEPhysicsProp::CMsgTEPhysicsProp(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.velocity_)*/ nullptr,
      /*decltype(_impl_.angles_)*/ nullptr,
      /*decltype(_impl_.dmgpos_)*/ nullptr,
      /*decltype(_impl_.dmgdir_)*/ nullptr,
      /*decltype(_impl_.skin_)*/ 0u,
      /*decltype(_impl_.flags_)*/ 0u,
      /*decltype(_impl_.effects_)*/ 0u,
      /*decltype(_impl_.color_)*/ 0u,
      /*decltype(_impl_.modelindex_)*/ ::uint64_t{0u},
      /*decltype(_impl_.unused_breakmodelsnottomake_)*/ 0u,
      /*decltype(_impl_.scale_)*/ 0,
      /*decltype(_impl_.dmgtype_)*/ 0,
    } {}
struct CMsgTEPhysicsPropDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEPhysicsPropDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEPhysicsPropDefaultTypeInternal() {}
  union {
    CMsgTEPhysicsProp _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEPhysicsPropDefaultTypeInternal _CMsgTEPhysicsProp_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEPlayerDecal::CMsgTEPlayerDecal(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.player_)*/ -1,
      /*decltype(_impl_.entity_)*/ -1,
    } {}
struct CMsgTEPlayerDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEPlayerDecalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEPlayerDecalDefaultTypeInternal() {}
  union {
    CMsgTEPlayerDecal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEPlayerDecalDefaultTypeInternal _CMsgTEPlayerDecal_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEProjectedDecal::CMsgTEProjectedDecal(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.angles_)*/ nullptr,
      /*decltype(_impl_.index_)*/ 0u,
      /*decltype(_impl_.distance_)*/ 0,
    } {}
struct CMsgTEProjectedDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEProjectedDecalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEProjectedDecalDefaultTypeInternal() {}
  union {
    CMsgTEProjectedDecal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEProjectedDecalDefaultTypeInternal _CMsgTEProjectedDecal_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTESmoke::CMsgTESmoke(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.scale_)*/ 0,
    } {}
struct CMsgTESmokeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTESmokeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTESmokeDefaultTypeInternal() {}
  union {
    CMsgTESmoke _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTESmokeDefaultTypeInternal _CMsgTESmoke_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR CMsgTEWorldDecal::CMsgTEWorldDecal(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.origin_)*/ nullptr,
      /*decltype(_impl_.normal_)*/ nullptr,
      /*decltype(_impl_.index_)*/ 0u,
    } {}
struct CMsgTEWorldDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEWorldDecalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEWorldDecalDefaultTypeInternal() {}
  union {
    CMsgTEWorldDecal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEWorldDecalDefaultTypeInternal _CMsgTEWorldDecal_default_instance_;
static ::_pb::Metadata file_level_metadata_te_2eproto[28];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_te_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_te_2eproto = nullptr;
const ::uint32_t TableStruct_te_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_.dir_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.modelindex_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.haloindex_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.startframe_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.framerate_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.life_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.width_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.endwidth_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.fadelength_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.amplitude_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.speed_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.flags_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.startentity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.endentity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.end_),
    0,
    3,
    4,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.startentity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.endentity_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.end_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.base_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.startentity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.endentity_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.normal_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.saxis_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.entity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.index_),
    0,
    1,
    2,
    4,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.mins_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.maxs_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.height_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.count_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.speed_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.mins_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.maxs_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.waterz_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.count_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.speed_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.entity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.hitbox_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.index_),
    0,
    1,
    4,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.normal_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.angles_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.entity_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.otherentity_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.scale_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.magnitude_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.surfaceprop_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.effectindex_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.damagetype_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.material_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.hitbox_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.attachmentindex_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.effectname_),
    PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.attachmentname_),
    0,
    1,
    2,
    3,
    17,
    18,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _impl_.effectdata_),
    0,
    PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.pos_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.dir_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.explosive_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.entity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.density_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.current_),
    2,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.angles_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.force_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.forcepos_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.width_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.height_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.shardsize_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.surfacetype_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.frontcolor_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.backcolor_),
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.scale_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.life_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.brightness_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.normal_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.type_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.angles_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.scale_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.type_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.amount_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.framerate_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.normal_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.materialtype_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.radius_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.magnitude_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.scale_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.affect_ragdolls_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.effect_name_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.explosion_type_),
    1,
    3,
    4,
    2,
    5,
    6,
    7,
    8,
    9,
    0,
    10,
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.size_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.speed_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.direction_),
    0,
    2,
    3,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_.reversed_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.magnitude_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.length_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.direction_),
    0,
    2,
    3,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.velocity_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.angles_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.skin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.effects_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.color_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.modelindex_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.unused_breakmodelsnottomake_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.scale_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgpos_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgdir_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgtype_),
    0,
    1,
    2,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    3,
    4,
    12,
    PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.player_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.entity_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.angles_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.index_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.distance_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_.scale_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.origin_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.normal_),
    PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.index_),
    0,
    1,
    2,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::CMsgTEArmorRicochet)},
        {12, 32, -1, sizeof(::CMsgTEBaseBeam)},
        {44, 57, -1, sizeof(::CMsgTEBeamEntPoint)},
        {62, 73, -1, sizeof(::CMsgTEBeamEnts)},
        {76, 87, -1, sizeof(::CMsgTEBeamPoints)},
        {90, 101, -1, sizeof(::CMsgTEBeamRing)},
        {104, 117, -1, sizeof(::CMsgTEBSPDecal)},
        {122, 135, -1, sizeof(::CMsgTEBubbles)},
        {140, 153, -1, sizeof(::CMsgTEBubbleTrail)},
        {158, 171, -1, sizeof(::CMsgTEDecal)},
        {176, 203, -1, sizeof(::CMsgEffectData)},
        {222, 231, -1, sizeof(::CMsgTEEffectDispatch)},
        {232, 243, -1, sizeof(::CMsgTEEnergySplash)},
        {246, 257, -1, sizeof(::CMsgTEFizz)},
        {260, 278, -1, sizeof(::CMsgTEShatterSurface)},
        {288, 300, -1, sizeof(::CMsgTEGlowSprite)},
        {304, 315, -1, sizeof(::CMsgTEImpact)},
        {318, 330, -1, sizeof(::CMsgTEMuzzleFlash)},
        {334, 346, -1, sizeof(::CMsgTEBloodStream)},
        {350, 369, -1, sizeof(::CMsgTEExplosion)},
        {380, 392, -1, sizeof(::CMsgTEDust)},
        {396, 406, -1, sizeof(::CMsgTELargeFunnel)},
        {408, 420, -1, sizeof(::CMsgTESparks)},
        {424, 445, -1, sizeof(::CMsgTEPhysicsProp)},
        {458, 469, -1, sizeof(::CMsgTEPlayerDecal)},
        {472, 484, -1, sizeof(::CMsgTEProjectedDecal)},
        {488, 498, -1, sizeof(::CMsgTESmoke)},
        {500, 511, -1, sizeof(::CMsgTEWorldDecal)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::_CMsgTEArmorRicochet_default_instance_._instance,
    &::_CMsgTEBaseBeam_default_instance_._instance,
    &::_CMsgTEBeamEntPoint_default_instance_._instance,
    &::_CMsgTEBeamEnts_default_instance_._instance,
    &::_CMsgTEBeamPoints_default_instance_._instance,
    &::_CMsgTEBeamRing_default_instance_._instance,
    &::_CMsgTEBSPDecal_default_instance_._instance,
    &::_CMsgTEBubbles_default_instance_._instance,
    &::_CMsgTEBubbleTrail_default_instance_._instance,
    &::_CMsgTEDecal_default_instance_._instance,
    &::_CMsgEffectData_default_instance_._instance,
    &::_CMsgTEEffectDispatch_default_instance_._instance,
    &::_CMsgTEEnergySplash_default_instance_._instance,
    &::_CMsgTEFizz_default_instance_._instance,
    &::_CMsgTEShatterSurface_default_instance_._instance,
    &::_CMsgTEGlowSprite_default_instance_._instance,
    &::_CMsgTEImpact_default_instance_._instance,
    &::_CMsgTEMuzzleFlash_default_instance_._instance,
    &::_CMsgTEBloodStream_default_instance_._instance,
    &::_CMsgTEExplosion_default_instance_._instance,
    &::_CMsgTEDust_default_instance_._instance,
    &::_CMsgTELargeFunnel_default_instance_._instance,
    &::_CMsgTESparks_default_instance_._instance,
    &::_CMsgTEPhysicsProp_default_instance_._instance,
    &::_CMsgTEPlayerDecal_default_instance_._instance,
    &::_CMsgTEProjectedDecal_default_instance_._instance,
    &::_CMsgTESmoke_default_instance_._instance,
    &::_CMsgTEWorldDecal_default_instance_._instance,
};
const char descriptor_table_protodef_te_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\010te.proto\032\026networkbasetypes.proto\"I\n\023CM"
    "sgTEArmorRicochet\022\030\n\003pos\030\001 \001(\0132\013.CMsgVec"
    "tor\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector\"\341\001\n\016CMsgTE"
    "BaseBeam\022\022\n\nmodelindex\030\001 \001(\006\022\021\n\thaloinde"
    "x\030\002 \001(\006\022\022\n\nstartframe\030\003 \001(\r\022\021\n\tframerate"
    "\030\004 \001(\r\022\014\n\004life\030\005 \001(\002\022\r\n\005width\030\006 \001(\002\022\020\n\010e"
    "ndwidth\030\007 \001(\002\022\022\n\nfadelength\030\010 \001(\r\022\021\n\tamp"
    "litude\030\t \001(\002\022\r\n\005color\030\n \001(\007\022\r\n\005speed\030\013 \001"
    "(\r\022\r\n\005flags\030\014 \001(\r\"\221\001\n\022CMsgTEBeamEntPoint"
    "\022\035\n\004base\030\001 \001(\0132\017.CMsgTEBaseBeam\022\023\n\013start"
    "entity\030\002 \001(\r\022\021\n\tendentity\030\003 \001(\r\022\032\n\005start"
    "\030\004 \001(\0132\013.CMsgVector\022\030\n\003end\030\005 \001(\0132\013.CMsgV"
    "ector\"W\n\016CMsgTEBeamEnts\022\035\n\004base\030\001 \001(\0132\017."
    "CMsgTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\te"
    "ndentity\030\003 \001(\r\"g\n\020CMsgTEBeamPoints\022\035\n\004ba"
    "se\030\001 \001(\0132\017.CMsgTEBaseBeam\022\032\n\005start\030\002 \001(\013"
    "2\013.CMsgVector\022\030\n\003end\030\003 \001(\0132\013.CMsgVector\""
    "W\n\016CMsgTEBeamRing\022\035\n\004base\030\001 \001(\0132\017.CMsgTE"
    "BaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tendenti"
    "ty\030\003 \001(\r\"\211\001\n\016CMsgTEBSPDecal\022\033\n\006origin\030\001 "
    "\001(\0132\013.CMsgVector\022\033\n\006normal\030\002 \001(\0132\013.CMsgV"
    "ector\022\032\n\005saxis\030\003 \001(\0132\013.CMsgVector\022\022\n\006ent"
    "ity\030\004 \001(\005:\002-1\022\r\n\005index\030\005 \001(\r\"s\n\rCMsgTEBu"
    "bbles\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004maxs"
    "\030\002 \001(\0132\013.CMsgVector\022\016\n\006height\030\003 \001(\002\022\r\n\005c"
    "ount\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"w\n\021CMsgTEBubbl"
    "eTrail\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004max"
    "s\030\002 \001(\0132\013.CMsgVector\022\016\n\006waterz\030\003 \001(\002\022\r\n\005"
    "count\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"y\n\013CMsgTEDeca"
    "l\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n\005start\030"
    "\002 \001(\0132\013.CMsgVector\022\022\n\006entity\030\003 \001(\005:\002-1\022\016"
    "\n\006hitbox\030\004 \001(\r\022\r\n\005index\030\005 \001(\r\"\261\003\n\016CMsgEf"
    "fectData\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n"
    "\005start\030\002 \001(\0132\013.CMsgVector\022\033\n\006normal\030\003 \001("
    "\0132\013.CMsgVector\022\033\n\006angles\030\004 \001(\0132\013.CMsgQAn"
    "gle\022\030\n\006entity\030\005 \001(\007:\01016777215\022\035\n\013otheren"
    "tity\030\006 \001(\007:\01016777215\022\r\n\005scale\030\007 \001(\002\022\021\n\tm"
    "agnitude\030\010 \001(\002\022\016\n\006radius\030\t \001(\002\022\023\n\013surfac"
    "eprop\030\n \001(\007\022\023\n\013effectindex\030\013 \001(\006\022\022\n\ndama"
    "getype\030\014 \001(\r\022\020\n\010material\030\r \001(\r\022\016\n\006hitbox"
    "\030\016 \001(\r\022\r\n\005color\030\017 \001(\r\022\r\n\005flags\030\020 \001(\r\022\027\n\017"
    "attachmentindex\030\021 \001(\005\022\022\n\neffectname\030\022 \001("
    "\r\022\026\n\016attachmentname\030\023 \001(\r\";\n\024CMsgTEEffec"
    "tDispatch\022#\n\neffectdata\030\001 \001(\0132\017.CMsgEffe"
    "ctData\"[\n\022CMsgTEEnergySplash\022\030\n\003pos\030\001 \001("
    "\0132\013.CMsgVector\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector"
    "\022\021\n\texplosive\030\003 \001(\010\"B\n\nCMsgTEFizz\022\022\n\006ent"
    "ity\030\001 \001(\005:\002-1\022\017\n\007density\030\002 \001(\r\022\017\n\007curren"
    "t\030\003 \001(\005\"\371\001\n\024CMsgTEShatterSurface\022\033\n\006orig"
    "in\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013."
    "CMsgQAngle\022\032\n\005force\030\003 \001(\0132\013.CMsgVector\022\035"
    "\n\010forcepos\030\004 \001(\0132\013.CMsgVector\022\r\n\005width\030\005"
    " \001(\002\022\016\n\006height\030\006 \001(\002\022\021\n\tshardsize\030\007 \001(\002\022"
    "\023\n\013surfacetype\030\010 \001(\r\022\022\n\nfrontcolor\030\t \001(\007"
    "\022\021\n\tbackcolor\030\n \001(\007\"`\n\020CMsgTEGlowSprite\022"
    "\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\r\n\005scale\030\002 "
    "\001(\002\022\014\n\004life\030\003 \001(\002\022\022\n\nbrightness\030\004 \001(\r\"V\n"
    "\014CMsgTEImpact\022\033\n\006origin\030\001 \001(\0132\013.CMsgVect"
    "or\022\033\n\006normal\030\002 \001(\0132\013.CMsgVector\022\014\n\004type\030"
    "\003 \001(\r\"j\n\021CMsgTEMuzzleFlash\022\033\n\006origin\030\001 \001"
    "(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013.CMsgQA"
    "ngle\022\r\n\005scale\030\003 \001(\002\022\014\n\004type\030\004 \001(\r\"o\n\021CMs"
    "gTEBloodStream\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
    "tor\022\036\n\tdirection\030\002 \001(\0132\013.CMsgVector\022\r\n\005c"
    "olor\030\003 \001(\007\022\016\n\006amount\030\004 \001(\r\"\373\001\n\017CMsgTEExp"
    "losion\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\021\n\tf"
    "ramerate\030\002 \001(\r\022\r\n\005flags\030\003 \001(\r\022\033\n\006normal\030"
    "\004 \001(\0132\013.CMsgVector\022\024\n\014materialtype\030\005 \001(\r"
    "\022\016\n\006radius\030\006 \001(\r\022\021\n\tmagnitude\030\007 \001(\r\022\r\n\005s"
    "cale\030\010 \001(\002\022\027\n\017affect_ragdolls\030\t \001(\010\022\023\n\013e"
    "ffect_name\030\n \001(\t\022\026\n\016explosion_type\030\013 \001(\r"
    "\"f\n\nCMsgTEDust\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
    "tor\022\014\n\004size\030\002 \001(\002\022\r\n\005speed\030\003 \001(\002\022\036\n\tdire"
    "ction\030\004 \001(\0132\013.CMsgVector\"B\n\021CMsgTELargeF"
    "unnel\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\020\n\010re"
    "versed\030\002 \001(\r\"n\n\014CMsgTESparks\022\033\n\006origin\030\001"
    " \001(\0132\013.CMsgVector\022\021\n\tmagnitude\030\002 \001(\r\022\016\n\006"
    "length\030\003 \001(\r\022\036\n\tdirection\030\004 \001(\0132\013.CMsgVe"
    "ctor\"\274\002\n\021CMsgTEPhysicsProp\022\033\n\006origin\030\001 \001"
    "(\0132\013.CMsgVector\022\035\n\010velocity\030\002 \001(\0132\013.CMsg"
    "Vector\022\033\n\006angles\030\003 \001(\0132\013.CMsgQAngle\022\014\n\004s"
    "kin\030\004 \001(\007\022\r\n\005flags\030\005 \001(\r\022\017\n\007effects\030\006 \001("
    "\r\022\r\n\005color\030\007 \001(\007\022\022\n\nmodelindex\030\010 \001(\006\022#\n\033"
    "unused_breakmodelsnottomake\030\t \001(\r\022\r\n\005sca"
    "le\030\n \001(\002\022\033\n\006dmgpos\030\013 \001(\0132\013.CMsgVector\022\033\n"
    "\006dmgdir\030\014 \001(\0132\013.CMsgVector\022\017\n\007dmgtype\030\r "
    "\001(\005\"X\n\021CMsgTEPlayerDecal\022\033\n\006origin\030\001 \001(\013"
    "2\013.CMsgVector\022\022\n\006player\030\002 \001(\005:\002-1\022\022\n\006ent"
    "ity\030\003 \001(\005:\002-1\"q\n\024CMsgTEProjectedDecal\022\033\n"
    "\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001"
    "(\0132\013.CMsgQAngle\022\r\n\005index\030\003 \001(\r\022\020\n\010distan"
    "ce\030\004 \001(\002\"9\n\013CMsgTESmoke\022\033\n\006origin\030\001 \001(\0132"
    "\013.CMsgVector\022\r\n\005scale\030\002 \001(\002\"[\n\020CMsgTEWor"
    "ldDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006"
    "normal\030\002 \001(\0132\013.CMsgVector\022\r\n\005index\030\003 \001(\r"
    "*\275\004\n\016ETEProtobufIds\022\030\n\023TE_EffectDispatch"
    "Id\020\220\003\022\027\n\022TE_ArmorRicochetId\020\221\003\022\026\n\021TE_Bea"
    "mEntPointId\020\222\003\022\022\n\rTE_BeamEntsId\020\223\003\022\024\n\017TE"
    "_BeamPointsId\020\224\003\022\022\n\rTE_BeamRingId\020\225\003\022\022\n\r"
    "TE_BSPDecalId\020\227\003\022\021\n\014TE_BubblesId\020\230\003\022\025\n\020T"
    "E_BubbleTrailId\020\231\003\022\017\n\nTE_DecalId\020\232\003\022\024\n\017T"
    "E_WorldDecalId\020\233\003\022\026\n\021TE_EnergySplashId\020\234"
    "\003\022\016\n\tTE_FizzId\020\235\003\022\030\n\023TE_ShatterSurfaceId"
    "\020\236\003\022\024\n\017TE_GlowSpriteId\020\237\003\022\020\n\013TE_ImpactId"
    "\020\240\003\022\025\n\020TE_MuzzleFlashId\020\241\003\022\025\n\020TE_BloodSt"
    "reamId\020\242\003\022\023\n\016TE_ExplosionId\020\243\003\022\016\n\tTE_Dus"
    "tId\020\244\003\022\025\n\020TE_LargeFunnelId\020\245\003\022\020\n\013TE_Spar"
    "ksId\020\246\003\022\025\n\020TE_PhysicsPropId\020\247\003\022\025\n\020TE_Pla"
    "yerDecalId\020\250\003\022\030\n\023TE_ProjectedDecalId\020\251\003\022"
    "\017\n\nTE_SmokeId\020\252\003"
};
static const ::_pbi::DescriptorTable* const descriptor_table_te_2eproto_deps[1] =
    {
        &::descriptor_table_networkbasetypes_2eproto,
};
static ::absl::once_flag descriptor_table_te_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_te_2eproto = {
    false,
    false,
    4376,
    descriptor_table_protodef_te_2eproto,
    "te.proto",
    &descriptor_table_te_2eproto_once,
    descriptor_table_te_2eproto_deps,
    1,
    28,
    schemas,
    file_default_instances,
    TableStruct_te_2eproto::offsets,
    file_level_metadata_te_2eproto,
    file_level_enum_descriptors_te_2eproto,
    file_level_service_descriptors_te_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_te_2eproto_getter() {
  return &descriptor_table_te_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_te_2eproto(&descriptor_table_te_2eproto);
const ::google::protobuf::EnumDescriptor* ETEProtobufIds_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_te_2eproto);
  return file_level_enum_descriptors_te_2eproto[0];
}
bool ETEProtobufIds_IsValid(int value) {
  switch (value) {
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class CMsgTEArmorRicochet::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEArmorRicochet>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEArmorRicochet* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEArmorRicochet* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector& CMsgTEArmorRicochet::_Internal::pos(const CMsgTEArmorRicochet* msg) {
  return *msg->_impl_.pos_;
}
const ::CMsgVector& CMsgTEArmorRicochet::_Internal::dir(const CMsgTEArmorRicochet* msg) {
  return *msg->_impl_.dir_;
}
void CMsgTEArmorRicochet::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEArmorRicochet::clear_dir() {
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEArmorRicochet)
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from) : ::google::protobuf::Message() {
  CMsgTEArmorRicochet* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.pos_){nullptr},
      decltype(_impl_.dir_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dir_ = new ::CMsgVector(*from._impl_.dir_);
  }

  // @@protoc_insertion_point(copy_constructor:CMsgTEArmorRicochet)
}
inline void CMsgTEArmorRicochet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.pos_){nullptr},
      decltype(_impl_.dir_){nullptr},
  };
}
CMsgTEArmorRicochet::~CMsgTEArmorRicochet() {
  // @@protoc_insertion_point(destructor:CMsgTEArmorRicochet)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEArmorRicochet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.dir_;
}
void CMsgTEArmorRicochet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEArmorRicochet::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEArmorRicochet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.dir_ != nullptr);
      _impl_.dir_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEArmorRicochet::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> CMsgTEArmorRicochet::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEArmorRicochet_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .CMsgVector dir = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.dir_)}},
    // optional .CMsgVector pos = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.pos_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector pos = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.pos_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector dir = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.dir_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEArmorRicochet::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEArmorRicochet)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dir(this),
        _Internal::dir(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEArmorRicochet)
  return target;
}

::size_t CMsgTEArmorRicochet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEArmorRicochet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.dir_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEArmorRicochet::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEArmorRicochet::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEArmorRicochet::GetClassData() const { return &_class_data_; }


void CMsgTEArmorRicochet::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEArmorRicochet*>(&to_msg);
  auto& from = static_cast<const CMsgTEArmorRicochet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEArmorRicochet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dir()->::CMsgVector::MergeFrom(
          from._internal_dir());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEArmorRicochet::CopyFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEArmorRicochet::IsInitialized() const {
  return true;
}

void CMsgTEArmorRicochet::InternalSwap(CMsgTEArmorRicochet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.dir_)
      + sizeof(CMsgTEArmorRicochet::_impl_.dir_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::google::protobuf::Metadata CMsgTEArmorRicochet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[0]);
}
// ===================================================================

class CMsgTEBaseBeam::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBaseBeam>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_._has_bits_);
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_haloindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_startframe(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_endwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fadelength(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_amplitude(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CMsgTEBaseBeam::CMsgTEBaseBeam(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBaseBeam)
}
CMsgTEBaseBeam::CMsgTEBaseBeam(const CMsgTEBaseBeam& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgTEBaseBeam)
}
inline void CMsgTEBaseBeam::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.modelindex_){::uint64_t{0u}},
      decltype(_impl_.haloindex_){::uint64_t{0u}},
      decltype(_impl_.startframe_){0u},
      decltype(_impl_.framerate_){0u},
      decltype(_impl_.life_){0},
      decltype(_impl_.width_){0},
      decltype(_impl_.endwidth_){0},
      decltype(_impl_.fadelength_){0u},
      decltype(_impl_.amplitude_){0},
      decltype(_impl_.color_){0u},
      decltype(_impl_.speed_){0u},
      decltype(_impl_.flags_){0u},
  };
}
CMsgTEBaseBeam::~CMsgTEBaseBeam() {
  // @@protoc_insertion_point(destructor:CMsgTEBaseBeam)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBaseBeam::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void CMsgTEBaseBeam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBaseBeam::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBaseBeam)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.modelindex_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.fadelength_) -
        reinterpret_cast<char*>(&_impl_.modelindex_)) + sizeof(_impl_.fadelength_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.amplitude_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.amplitude_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBaseBeam::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 0, 0, 2> CMsgTEBaseBeam::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CMsgTEBaseBeam_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional fixed64 modelindex = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.modelindex_)}},
    // optional fixed64 haloindex = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.haloindex_)}},
    // optional uint32 startframe = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBaseBeam, _impl_.startframe_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.startframe_)}},
    // optional uint32 framerate = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBaseBeam, _impl_.framerate_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.framerate_)}},
    // optional float life = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.life_)}},
    // optional float width = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.width_)}},
    // optional float endwidth = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.endwidth_)}},
    // optional uint32 fadelength = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBaseBeam, _impl_.fadelength_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.fadelength_)}},
    // optional float amplitude = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.amplitude_)}},
    // optional fixed32 color = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.color_)}},
    // optional uint32 speed = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBaseBeam, _impl_.speed_), 10>(),
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.speed_)}},
    // optional uint32 flags = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBaseBeam, _impl_.flags_), 11>(),
     {96, 11, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.flags_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 modelindex = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.modelindex_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional fixed64 haloindex = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.haloindex_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional uint32 startframe = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.startframe_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 framerate = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.framerate_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float life = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.life_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float width = 6;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.width_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float endwidth = 7;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.endwidth_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 fadelength = 8;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.fadelength_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float amplitude = 9;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.amplitude_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional fixed32 color = 10;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.color_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 speed = 11;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.speed_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 flags = 12;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.flags_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CMsgTEBaseBeam::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBaseBeam)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 modelindex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this->_internal_modelindex(), target);
  }

  // optional fixed64 haloindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        2, this->_internal_haloindex(), target);
  }

  // optional uint32 startframe = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_startframe(), target);
  }

  // optional uint32 framerate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_framerate(), target);
  }

  // optional float life = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_life(), target);
  }

  // optional float width = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_width(), target);
  }

  // optional float endwidth = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_endwidth(), target);
  }

  // optional uint32 fadelength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_fadelength(), target);
  }

  // optional float amplitude = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_amplitude(), target);
  }

  // optional fixed32 color = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        10, this->_internal_color(), target);
  }

  // optional uint32 speed = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_speed(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        12, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBaseBeam)
  return target;
}

::size_t CMsgTEBaseBeam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBaseBeam)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 modelindex = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 9;
    }

    // optional fixed64 haloindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 9;
    }

    // optional uint32 startframe = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_startframe());
    }

    // optional uint32 framerate = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_framerate());
    }

    // optional float life = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // optional float width = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // optional float endwidth = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // optional uint32 fadelength = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_fadelength());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float amplitude = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // optional fixed32 color = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

    // optional uint32 speed = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_speed());
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBaseBeam::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBaseBeam::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBaseBeam::GetClassData() const { return &_class_data_; }


void CMsgTEBaseBeam::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBaseBeam*>(&to_msg);
  auto& from = static_cast<const CMsgTEBaseBeam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBaseBeam)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.modelindex_ = from._impl_.modelindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.haloindex_ = from._impl_.haloindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.startframe_ = from._impl_.startframe_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.framerate_ = from._impl_.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.life_ = from._impl_.life_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.endwidth_ = from._impl_.endwidth_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.fadelength_ = from._impl_.fadelength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.amplitude_ = from._impl_.amplitude_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBaseBeam::CopyFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBaseBeam::IsInitialized() const {
  return true;
}

void CMsgTEBaseBeam::InternalSwap(CMsgTEBaseBeam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.flags_)
      + sizeof(CMsgTEBaseBeam::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.modelindex_)>(
          reinterpret_cast<char*>(&_impl_.modelindex_),
          reinterpret_cast<char*>(&other->_impl_.modelindex_));
}

::google::protobuf::Metadata CMsgTEBaseBeam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[1]);
}
// ===================================================================

class CMsgTEBeamEntPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEntPoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEntPoint* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamEntPoint* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamEntPoint* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam& CMsgTEBeamEntPoint::_Internal::base(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector& CMsgTEBeamEntPoint::_Internal::start(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector& CMsgTEBeamEntPoint::_Internal::end(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.end_;
}
void CMsgTEBeamEntPoint::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEntPoint::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEntPoint)
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from) : ::google::protobuf::Message() {
  CMsgTEBeamEntPoint* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.end_){nullptr},
      decltype(_impl_.startentity_){},
      decltype(_impl_.endentity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.end_ = new ::CMsgVector(*from._impl_.end_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEntPoint)
}
inline void CMsgTEBeamEntPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.end_){nullptr},
      decltype(_impl_.startentity_){0u},
      decltype(_impl_.endentity_){0u},
  };
}
CMsgTEBeamEntPoint::~CMsgTEBeamEntPoint() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEntPoint)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBeamEntPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}
void CMsgTEBeamEntPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBeamEntPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEntPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.startentity_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBeamEntPoint::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 3, 0, 2> CMsgTEBeamEntPoint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBeamEntPoint_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgTEBaseBeam base = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.base_)}},
    // optional uint32 startentity = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamEntPoint, _impl_.startentity_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.startentity_)}},
    // optional uint32 endentity = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamEntPoint, _impl_.endentity_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.endentity_)}},
    // optional .CMsgVector start = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.start_)}},
    // optional .CMsgVector end = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.end_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgTEBaseBeam base = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.base_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 startentity = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.startentity_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 endentity = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.endentity_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .CMsgVector start = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.start_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector end = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.end_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgTEBaseBeam>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBeamEntPoint::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEntPoint)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_endentity(), target);
  }

  // optional .CMsgVector start = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector end = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEntPoint)
  return target;
}

::size_t CMsgTEBeamEntPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEntPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector start = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector end = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBeamEntPoint::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBeamEntPoint::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBeamEntPoint::GetClassData() const { return &_class_data_; }


void CMsgTEBeamEntPoint::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamEntPoint*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamEntPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEntPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end()->::CMsgVector::MergeFrom(
          from._internal_end());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamEntPoint::CopyFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBeamEntPoint::IsInitialized() const {
  return true;
}

void CMsgTEBeamEntPoint::InternalSwap(CMsgTEBeamEntPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.endentity_)
      + sizeof(CMsgTEBeamEntPoint::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::google::protobuf::Metadata CMsgTEBeamEntPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[2]);
}
// ===================================================================

class CMsgTEBeamEnts::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEnts>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEnts* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam& CMsgTEBeamEnts::_Internal::base(const CMsgTEBeamEnts* msg) {
  return *msg->_impl_.base_;
}
CMsgTEBeamEnts::CMsgTEBeamEnts(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEnts)
}
CMsgTEBeamEnts::CMsgTEBeamEnts(const CMsgTEBeamEnts& from) : ::google::protobuf::Message() {
  CMsgTEBeamEnts* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.startentity_){},
      decltype(_impl_.endentity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEnts)
}
inline void CMsgTEBeamEnts::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.startentity_){0u},
      decltype(_impl_.endentity_){0u},
  };
}
CMsgTEBeamEnts::~CMsgTEBeamEnts() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEnts)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBeamEnts::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}
void CMsgTEBeamEnts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBeamEnts::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEnts)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.startentity_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBeamEnts::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CMsgTEBeamEnts::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBeamEnts_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgTEBaseBeam base = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.base_)}},
    // optional uint32 startentity = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamEnts, _impl_.startentity_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.startentity_)}},
    // optional uint32 endentity = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamEnts, _impl_.endentity_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.endentity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgTEBaseBeam base = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.base_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 startentity = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.startentity_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 endentity = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.endentity_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgTEBaseBeam>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBeamEnts::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEnts)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEnts)
  return target;
}

::size_t CMsgTEBeamEnts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEnts)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBeamEnts::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBeamEnts::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBeamEnts::GetClassData() const { return &_class_data_; }


void CMsgTEBeamEnts::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamEnts*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamEnts&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEnts)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamEnts::CopyFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBeamEnts::IsInitialized() const {
  return true;
}

void CMsgTEBeamEnts::InternalSwap(CMsgTEBeamEnts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.endentity_)
      + sizeof(CMsgTEBeamEnts::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::google::protobuf::Metadata CMsgTEBeamEnts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[3]);
}
// ===================================================================

class CMsgTEBeamPoints::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamPoints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamPoints* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamPoints* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamPoints* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam& CMsgTEBeamPoints::_Internal::base(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector& CMsgTEBeamPoints::_Internal::start(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector& CMsgTEBeamPoints::_Internal::end(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.end_;
}
void CMsgTEBeamPoints::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamPoints::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamPoints::CMsgTEBeamPoints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamPoints)
}
CMsgTEBeamPoints::CMsgTEBeamPoints(const CMsgTEBeamPoints& from) : ::google::protobuf::Message() {
  CMsgTEBeamPoints* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.end_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.end_ = new ::CMsgVector(*from._impl_.end_);
  }

  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamPoints)
}
inline void CMsgTEBeamPoints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.end_){nullptr},
  };
}
CMsgTEBeamPoints::~CMsgTEBeamPoints() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamPoints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBeamPoints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}
void CMsgTEBeamPoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBeamPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamPoints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBeamPoints::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> CMsgTEBeamPoints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBeamPoints_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgTEBaseBeam base = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.base_)}},
    // optional .CMsgVector start = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.start_)}},
    // optional .CMsgVector end = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.end_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgTEBaseBeam base = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.base_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector start = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.start_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector end = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.end_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgTEBaseBeam>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBeamPoints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamPoints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamPoints)
  return target;
}

::size_t CMsgTEBeamPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamPoints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBeamPoints::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBeamPoints::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBeamPoints::GetClassData() const { return &_class_data_; }


void CMsgTEBeamPoints::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamPoints*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamPoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamPoints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end()->::CMsgVector::MergeFrom(
          from._internal_end());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamPoints::CopyFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBeamPoints::IsInitialized() const {
  return true;
}

void CMsgTEBeamPoints::InternalSwap(CMsgTEBeamPoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.end_)
      + sizeof(CMsgTEBeamPoints::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::google::protobuf::Metadata CMsgTEBeamPoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[4]);
}
// ===================================================================

class CMsgTEBeamRing::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamRing>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamRing* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam& CMsgTEBeamRing::_Internal::base(const CMsgTEBeamRing* msg) {
  return *msg->_impl_.base_;
}
CMsgTEBeamRing::CMsgTEBeamRing(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamRing)
}
CMsgTEBeamRing::CMsgTEBeamRing(const CMsgTEBeamRing& from) : ::google::protobuf::Message() {
  CMsgTEBeamRing* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.startentity_){},
      decltype(_impl_.endentity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamRing)
}
inline void CMsgTEBeamRing::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.base_){nullptr},
      decltype(_impl_.startentity_){0u},
      decltype(_impl_.endentity_){0u},
  };
}
CMsgTEBeamRing::~CMsgTEBeamRing() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamRing)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBeamRing::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}
void CMsgTEBeamRing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBeamRing::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamRing)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.startentity_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBeamRing::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CMsgTEBeamRing::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBeamRing_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgTEBaseBeam base = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.base_)}},
    // optional uint32 startentity = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamRing, _impl_.startentity_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.startentity_)}},
    // optional uint32 endentity = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBeamRing, _impl_.endentity_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.endentity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgTEBaseBeam base = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.base_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 startentity = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.startentity_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 endentity = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.endentity_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgTEBaseBeam>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBeamRing::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamRing)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamRing)
  return target;
}

::size_t CMsgTEBeamRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamRing)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBeamRing::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBeamRing::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBeamRing::GetClassData() const { return &_class_data_; }


void CMsgTEBeamRing::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamRing*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamRing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamRing)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamRing::CopyFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBeamRing::IsInitialized() const {
  return true;
}

void CMsgTEBeamRing::InternalSwap(CMsgTEBeamRing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.endentity_)
      + sizeof(CMsgTEBeamRing::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::google::protobuf::Metadata CMsgTEBeamRing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[5]);
}
// ===================================================================

class CMsgTEBSPDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBSPDecal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBSPDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEBSPDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& saxis(const CMsgTEBSPDecal* msg);
  static void set_has_saxis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEBSPDecal::_Internal::origin(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEBSPDecal::_Internal::normal(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.normal_;
}
const ::CMsgVector& CMsgTEBSPDecal::_Internal::saxis(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.saxis_;
}
void CMsgTEBSPDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBSPDecal::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBSPDecal::clear_saxis() {
  if (_impl_.saxis_ != nullptr) _impl_.saxis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBSPDecal::CMsgTEBSPDecal(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBSPDecal)
}
CMsgTEBSPDecal::CMsgTEBSPDecal(const CMsgTEBSPDecal& from) : ::google::protobuf::Message() {
  CMsgTEBSPDecal* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.saxis_){nullptr},
      decltype(_impl_.index_){},
      decltype(_impl_.entity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.saxis_ = new ::CMsgVector(*from._impl_.saxis_);
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.entity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBSPDecal)
}
inline void CMsgTEBSPDecal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.saxis_){nullptr},
      decltype(_impl_.index_){0u},
      decltype(_impl_.entity_){-1},
  };
}
CMsgTEBSPDecal::~CMsgTEBSPDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEBSPDecal)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBSPDecal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
  if (this != internal_default_instance()) delete _impl_.saxis_;
}
void CMsgTEBSPDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBSPDecal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.saxis_ != nullptr);
      _impl_.saxis_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    _impl_.index_ = 0u;
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBSPDecal::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 3, 0, 2> CMsgTEBSPDecal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBSPDecal_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.origin_)}},
    // optional .CMsgVector normal = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.normal_)}},
    // optional .CMsgVector saxis = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.saxis_)}},
    // optional int32 entity = 4 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBSPDecal, _impl_.entity_), 4>(),
     {32, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.entity_)}},
    // optional uint32 index = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBSPDecal, _impl_.index_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.index_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector normal = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.normal_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector saxis = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.saxis_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 entity = 4 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.entity_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 index = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.index_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBSPDecal::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBSPDecal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector saxis = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::saxis(this),
        _Internal::saxis(this).GetCachedSize(), target, stream);
  }

  // optional int32 entity = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_entity(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBSPDecal)
  return target;
}

::size_t CMsgTEBSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBSPDecal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional .CMsgVector saxis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.saxis_);
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_index());
    }

    // optional int32 entity = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBSPDecal::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBSPDecal::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBSPDecal::GetClassData() const { return &_class_data_; }


void CMsgTEBSPDecal::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBSPDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEBSPDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBSPDecal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_saxis()->::CMsgVector::MergeFrom(
          from._internal_saxis());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBSPDecal::CopyFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBSPDecal::IsInitialized() const {
  return true;
}

void CMsgTEBSPDecal::InternalSwap(CMsgTEBSPDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.entity_)
      + sizeof(CMsgTEBSPDecal::_impl_.entity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEBSPDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[6]);
}
// ===================================================================

class CMsgTEBubbles::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbles>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbles* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbles* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector& CMsgTEBubbles::_Internal::mins(const CMsgTEBubbles* msg) {
  return *msg->_impl_.mins_;
}
const ::CMsgVector& CMsgTEBubbles::_Internal::maxs(const CMsgTEBubbles* msg) {
  return *msg->_impl_.maxs_;
}
void CMsgTEBubbles::clear_mins() {
  if (_impl_.mins_ != nullptr) _impl_.mins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbles::clear_maxs() {
  if (_impl_.maxs_ != nullptr) _impl_.maxs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbles::CMsgTEBubbles(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbles)
}
CMsgTEBubbles::CMsgTEBubbles(const CMsgTEBubbles& from) : ::google::protobuf::Message() {
  CMsgTEBubbles* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.mins_){nullptr},
      decltype(_impl_.maxs_){nullptr},
      decltype(_impl_.height_){},
      decltype(_impl_.count_){},
      decltype(_impl_.speed_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.mins_ = new ::CMsgVector(*from._impl_.mins_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.maxs_ = new ::CMsgVector(*from._impl_.maxs_);
  }
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.speed_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbles)
}
inline void CMsgTEBubbles::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.mins_){nullptr},
      decltype(_impl_.maxs_){nullptr},
      decltype(_impl_.height_){0},
      decltype(_impl_.count_){0u},
      decltype(_impl_.speed_){0},
  };
}
CMsgTEBubbles::~CMsgTEBubbles() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbles)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBubbles::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mins_;
  if (this != internal_default_instance()) delete _impl_.maxs_;
}
void CMsgTEBubbles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBubbles::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbles)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.mins_ != nullptr);
      _impl_.mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.maxs_ != nullptr);
      _impl_.maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.height_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBubbles::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> CMsgTEBubbles::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBubbles_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector mins = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.mins_)}},
    // optional .CMsgVector maxs = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.maxs_)}},
    // optional float height = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.height_)}},
    // optional uint32 count = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBubbles, _impl_.count_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.count_)}},
    // optional float speed = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.speed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector mins = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.mins_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector maxs = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.maxs_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float height = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.height_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 count = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.count_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float speed = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.speed_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBubbles::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbles)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mins(this),
        _Internal::mins(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::maxs(this),
        _Internal::maxs(this).GetCachedSize(), target, stream);
  }

  // optional float height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_height(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbles)
  return target;
}

::size_t CMsgTEBubbles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbles)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.maxs_);
    }

    // optional float height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBubbles::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBubbles::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBubbles::GetClassData() const { return &_class_data_; }


void CMsgTEBubbles::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBubbles*>(&to_msg);
  auto& from = static_cast<const CMsgTEBubbles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbles)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_mins()->::CMsgVector::MergeFrom(
          from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maxs()->::CMsgVector::MergeFrom(
          from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBubbles::CopyFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBubbles::IsInitialized() const {
  return true;
}

void CMsgTEBubbles::InternalSwap(CMsgTEBubbles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.speed_)
      + sizeof(CMsgTEBubbles::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.mins_)>(
          reinterpret_cast<char*>(&_impl_.mins_),
          reinterpret_cast<char*>(&other->_impl_.mins_));
}

::google::protobuf::Metadata CMsgTEBubbles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[7]);
}
// ===================================================================

class CMsgTEBubbleTrail::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbleTrail>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbleTrail* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbleTrail* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waterz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector& CMsgTEBubbleTrail::_Internal::mins(const CMsgTEBubbleTrail* msg) {
  return *msg->_impl_.mins_;
}
const ::CMsgVector& CMsgTEBubbleTrail::_Internal::maxs(const CMsgTEBubbleTrail* msg) {
  return *msg->_impl_.maxs_;
}
void CMsgTEBubbleTrail::clear_mins() {
  if (_impl_.mins_ != nullptr) _impl_.mins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbleTrail::clear_maxs() {
  if (_impl_.maxs_ != nullptr) _impl_.maxs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbleTrail)
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from) : ::google::protobuf::Message() {
  CMsgTEBubbleTrail* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.mins_){nullptr},
      decltype(_impl_.maxs_){nullptr},
      decltype(_impl_.waterz_){},
      decltype(_impl_.count_){},
      decltype(_impl_.speed_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.mins_ = new ::CMsgVector(*from._impl_.mins_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.maxs_ = new ::CMsgVector(*from._impl_.maxs_);
  }
  ::memcpy(&_impl_.waterz_, &from._impl_.waterz_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.waterz_)) + sizeof(_impl_.speed_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbleTrail)
}
inline void CMsgTEBubbleTrail::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.mins_){nullptr},
      decltype(_impl_.maxs_){nullptr},
      decltype(_impl_.waterz_){0},
      decltype(_impl_.count_){0u},
      decltype(_impl_.speed_){0},
  };
}
CMsgTEBubbleTrail::~CMsgTEBubbleTrail() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbleTrail)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBubbleTrail::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mins_;
  if (this != internal_default_instance()) delete _impl_.maxs_;
}
void CMsgTEBubbleTrail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBubbleTrail::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbleTrail)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.mins_ != nullptr);
      _impl_.mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.maxs_ != nullptr);
      _impl_.maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.waterz_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.waterz_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBubbleTrail::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> CMsgTEBubbleTrail::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBubbleTrail_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector mins = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.mins_)}},
    // optional .CMsgVector maxs = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.maxs_)}},
    // optional float waterz = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.waterz_)}},
    // optional uint32 count = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBubbleTrail, _impl_.count_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.count_)}},
    // optional float speed = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.speed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector mins = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.mins_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector maxs = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.maxs_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float waterz = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.waterz_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 count = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.count_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float speed = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.speed_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBubbleTrail::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbleTrail)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mins(this),
        _Internal::mins(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::maxs(this),
        _Internal::maxs(this).GetCachedSize(), target, stream);
  }

  // optional float waterz = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_waterz(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbleTrail)
  return target;
}

::size_t CMsgTEBubbleTrail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbleTrail)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.maxs_);
    }

    // optional float waterz = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBubbleTrail::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBubbleTrail::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBubbleTrail::GetClassData() const { return &_class_data_; }


void CMsgTEBubbleTrail::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBubbleTrail*>(&to_msg);
  auto& from = static_cast<const CMsgTEBubbleTrail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbleTrail)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_mins()->::CMsgVector::MergeFrom(
          from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maxs()->::CMsgVector::MergeFrom(
          from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.waterz_ = from._impl_.waterz_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBubbleTrail::CopyFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBubbleTrail::IsInitialized() const {
  return true;
}

void CMsgTEBubbleTrail::InternalSwap(CMsgTEBubbleTrail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.speed_)
      + sizeof(CMsgTEBubbleTrail::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.mins_)>(
          reinterpret_cast<char*>(&_impl_.mins_),
          reinterpret_cast<char*>(&other->_impl_.mins_));
}

::google::protobuf::Metadata CMsgTEBubbleTrail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[8]);
}
// ===================================================================

class CMsgTEDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDecal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEDecal* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEDecal::_Internal::origin(const CMsgTEDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEDecal::_Internal::start(const CMsgTEDecal* msg) {
  return *msg->_impl_.start_;
}
void CMsgTEDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDecal::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEDecal::CMsgTEDecal(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDecal)
}
CMsgTEDecal::CMsgTEDecal(const CMsgTEDecal& from) : ::google::protobuf::Message() {
  CMsgTEDecal* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.hitbox_){},
      decltype(_impl_.index_){},
      decltype(_impl_.entity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  ::memcpy(&_impl_.hitbox_, &from._impl_.hitbox_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.hitbox_)) + sizeof(_impl_.entity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEDecal)
}
inline void CMsgTEDecal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.hitbox_){0u},
      decltype(_impl_.index_){0u},
      decltype(_impl_.entity_){-1},
  };
}
CMsgTEDecal::~CMsgTEDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEDecal)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEDecal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.start_;
}
void CMsgTEDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDecal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.hitbox_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.hitbox_)) + sizeof(_impl_.index_));
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEDecal::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> CMsgTEDecal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEDecal_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.origin_)}},
    // optional .CMsgVector start = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.start_)}},
    // optional int32 entity = 3 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEDecal, _impl_.entity_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.entity_)}},
    // optional uint32 hitbox = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEDecal, _impl_.hitbox_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.hitbox_)}},
    // optional uint32 index = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEDecal, _impl_.index_), 3>(),
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.index_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector start = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.start_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 entity = 3 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.entity_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 hitbox = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.hitbox_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 index = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.index_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEDecal::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDecal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional int32 entity = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_entity(), target);
  }

  // optional uint32 hitbox = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_hitbox(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDecal)
  return target;
}

::size_t CMsgTEDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDecal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional uint32 hitbox = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_hitbox());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_index());
    }

    // optional int32 entity = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEDecal::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEDecal::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEDecal::GetClassData() const { return &_class_data_; }


void CMsgTEDecal::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDecal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hitbox_ = from._impl_.hitbox_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEDecal::CopyFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEDecal::IsInitialized() const {
  return true;
}

void CMsgTEDecal::InternalSwap(CMsgTEDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.entity_)
      + sizeof(CMsgTEDecal::_impl_.entity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[9]);
}
// ===================================================================

class CMsgEffectData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgEffectData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgEffectData* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgEffectData* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& normal(const CMsgEffectData* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgQAngle& angles(const CMsgEffectData* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_otherentity(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surfaceprop(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_effectindex(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_damagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_material(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_attachmentindex(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_effectname(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_attachmentname(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

const ::CMsgVector& CMsgEffectData::_Internal::origin(const CMsgEffectData* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgEffectData::_Internal::start(const CMsgEffectData* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector& CMsgEffectData::_Internal::normal(const CMsgEffectData* msg) {
  return *msg->_impl_.normal_;
}
const ::CMsgQAngle& CMsgEffectData::_Internal::angles(const CMsgEffectData* msg) {
  return *msg->_impl_.angles_;
}
void CMsgEffectData::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgEffectData::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgEffectData::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgEffectData::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgEffectData::CMsgEffectData(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgEffectData)
}
CMsgEffectData::CMsgEffectData(const CMsgEffectData& from) : ::google::protobuf::Message() {
  CMsgEffectData* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.scale_){},
      decltype(_impl_.magnitude_){},
      decltype(_impl_.radius_){},
      decltype(_impl_.surfaceprop_){},
      decltype(_impl_.effectindex_){},
      decltype(_impl_.damagetype_){},
      decltype(_impl_.material_){},
      decltype(_impl_.hitbox_){},
      decltype(_impl_.color_){},
      decltype(_impl_.flags_){},
      decltype(_impl_.attachmentindex_){},
      decltype(_impl_.effectname_){},
      decltype(_impl_.attachmentname_){},
      decltype(_impl_.entity_){},
      decltype(_impl_.otherentity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.otherentity_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.otherentity_));

  // @@protoc_insertion_point(copy_constructor:CMsgEffectData)
}
inline void CMsgEffectData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.start_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.scale_){0},
      decltype(_impl_.magnitude_){0},
      decltype(_impl_.radius_){0},
      decltype(_impl_.surfaceprop_){0u},
      decltype(_impl_.effectindex_){::uint64_t{0u}},
      decltype(_impl_.damagetype_){0u},
      decltype(_impl_.material_){0u},
      decltype(_impl_.hitbox_){0u},
      decltype(_impl_.color_){0u},
      decltype(_impl_.flags_){0u},
      decltype(_impl_.attachmentindex_){0},
      decltype(_impl_.effectname_){0u},
      decltype(_impl_.attachmentname_){0u},
      decltype(_impl_.entity_){16777215u},
      decltype(_impl_.otherentity_){16777215u},
  };
}
CMsgEffectData::~CMsgEffectData() {
  // @@protoc_insertion_point(destructor:CMsgEffectData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgEffectData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.normal_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}
void CMsgEffectData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgEffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgEffectData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.scale_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.surfaceprop_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.surfaceprop_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.effectindex_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.effectname_) -
        reinterpret_cast<char*>(&_impl_.effectindex_)) + sizeof(_impl_.effectname_));
  }
  if (cached_has_bits & 0x00070000u) {
    _impl_.attachmentname_ = 0u;
    _impl_.entity_ = 16777215u;
    _impl_.otherentity_ = 16777215u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgEffectData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 19, 4, 0, 2> CMsgEffectData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_._has_bits_),
    0, // no _extensions_
    19, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294443008,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgEffectData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.origin_)}},
    // optional .CMsgVector start = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.start_)}},
    // optional .CMsgVector normal = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.normal_)}},
    // optional .CMsgQAngle angles = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.angles_)}},
    // optional fixed32 entity = 5 [default = 16777215];
    {::_pbi::TcParser::FastF32S1,
     {45, 17, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.entity_)}},
    // optional fixed32 otherentity = 6 [default = 16777215];
    {::_pbi::TcParser::FastF32S1,
     {53, 18, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.otherentity_)}},
    // optional float scale = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.scale_)}},
    // optional float magnitude = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 5, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.magnitude_)}},
    // optional float radius = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 6, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.radius_)}},
    // optional fixed32 surfaceprop = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 7, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.surfaceprop_)}},
    // optional fixed64 effectindex = 11;
    {::_pbi::TcParser::FastF64S1,
     {89, 8, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.effectindex_)}},
    // optional uint32 damagetype = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgEffectData, _impl_.damagetype_), 9>(),
     {96, 9, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.damagetype_)}},
    // optional uint32 material = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgEffectData, _impl_.material_), 10>(),
     {104, 10, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.material_)}},
    // optional uint32 hitbox = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgEffectData, _impl_.hitbox_), 11>(),
     {112, 11, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.hitbox_)}},
    // optional uint32 color = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgEffectData, _impl_.color_), 12>(),
     {120, 12, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.color_)}},
    // optional uint32 flags = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 13, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.flags_)}},
    // optional int32 attachmentindex = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 14, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.attachmentindex_)}},
    // optional uint32 effectname = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 15, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.effectname_)}},
    // optional uint32 attachmentname = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 16, 0, PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.attachmentname_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector start = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.start_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector normal = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.normal_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgQAngle angles = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.angles_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional fixed32 entity = 5 [default = 16777215];
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.entity_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 otherentity = 6 [default = 16777215];
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.otherentity_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional float scale = 7;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.scale_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float magnitude = 8;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.magnitude_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float radius = 9;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.radius_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional fixed32 surfaceprop = 10;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.surfaceprop_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed64 effectindex = 11;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.effectindex_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional uint32 damagetype = 12;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.damagetype_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 material = 13;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.material_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 hitbox = 14;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.hitbox_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 color = 15;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.color_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 flags = 16;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.flags_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 attachmentindex = 17;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.attachmentindex_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 effectname = 18;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.effectname_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 attachmentname = 19;
    {PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.attachmentname_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgQAngle>()},
  }}, {{
  }},
};

::uint8_t* CMsgEffectData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgEffectData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 entity = 5 [default = 16777215];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        5, this->_internal_entity(), target);
  }

  // optional fixed32 otherentity = 6 [default = 16777215];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        6, this->_internal_otherentity(), target);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_scale(), target);
  }

  // optional float magnitude = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_magnitude(), target);
  }

  // optional float radius = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_radius(), target);
  }

  // optional fixed32 surfaceprop = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        10, this->_internal_surfaceprop(), target);
  }

  // optional fixed64 effectindex = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        11, this->_internal_effectindex(), target);
  }

  // optional uint32 damagetype = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        12, this->_internal_damagetype(), target);
  }

  // optional uint32 material = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        13, this->_internal_material(), target);
  }

  // optional uint32 hitbox = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        14, this->_internal_hitbox(), target);
  }

  // optional uint32 color = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_color(), target);
  }

  // optional uint32 flags = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_flags(), target);
  }

  // optional int32 attachmentindex = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        17, this->_internal_attachmentindex(), target);
  }

  // optional uint32 effectname = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        18, this->_internal_effectname(), target);
  }

  // optional uint32 attachmentname = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        19, this->_internal_attachmentname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgEffectData)
  return target;
}

::size_t CMsgEffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgEffectData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector normal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional .CMsgQAngle angles = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional float scale = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // optional float magnitude = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // optional float radius = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // optional fixed32 surfaceprop = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 5;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional fixed64 effectindex = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }

    // optional uint32 damagetype = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_damagetype());
    }

    // optional uint32 material = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_material());
    }

    // optional uint32 hitbox = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_hitbox());
    }

    // optional uint32 color = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_color());
    }

    // optional uint32 flags = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_flags());
    }

    // optional int32 attachmentindex = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_attachmentindex());
    }

    // optional uint32 effectname = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_effectname());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 attachmentname = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_attachmentname());
    }

    // optional fixed32 entity = 5 [default = 16777215];
    if (cached_has_bits & 0x00020000u) {
      total_size += 5;
    }

    // optional fixed32 otherentity = 6 [default = 16777215];
    if (cached_has_bits & 0x00040000u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgEffectData::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgEffectData::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgEffectData::GetClassData() const { return &_class_data_; }


void CMsgEffectData::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgEffectData*>(&to_msg);
  auto& from = static_cast<const CMsgEffectData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgEffectData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.surfaceprop_ = from._impl_.surfaceprop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.effectindex_ = from._impl_.effectindex_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.damagetype_ = from._impl_.damagetype_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.material_ = from._impl_.material_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.hitbox_ = from._impl_.hitbox_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.attachmentindex_ = from._impl_.attachmentindex_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.effectname_ = from._impl_.effectname_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.attachmentname_ = from._impl_.attachmentname_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.otherentity_ = from._impl_.otherentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgEffectData::CopyFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgEffectData::IsInitialized() const {
  return true;
}

void CMsgEffectData::InternalSwap(CMsgEffectData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.otherentity_)
      + sizeof(CMsgEffectData::_impl_.otherentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgEffectData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[10]);
}
// ===================================================================

class CMsgTEEffectDispatch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEffectDispatch>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEEffectDispatch, _impl_._has_bits_);
  static const ::CMsgEffectData& effectdata(const CMsgTEEffectDispatch* msg);
  static void set_has_effectdata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgEffectData& CMsgTEEffectDispatch::_Internal::effectdata(const CMsgTEEffectDispatch* msg) {
  return *msg->_impl_.effectdata_;
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEffectDispatch)
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from) : ::google::protobuf::Message() {
  CMsgTEEffectDispatch* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.effectdata_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.effectdata_ = new ::CMsgEffectData(*from._impl_.effectdata_);
  }

  // @@protoc_insertion_point(copy_constructor:CMsgTEEffectDispatch)
}
inline void CMsgTEEffectDispatch::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.effectdata_){nullptr},
  };
}
CMsgTEEffectDispatch::~CMsgTEEffectDispatch() {
  // @@protoc_insertion_point(destructor:CMsgTEEffectDispatch)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEEffectDispatch::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.effectdata_;
}
void CMsgTEEffectDispatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEEffectDispatch::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEffectDispatch)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.effectdata_ != nullptr);
    _impl_.effectdata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEEffectDispatch::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> CMsgTEEffectDispatch::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEEffectDispatch, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEEffectDispatch_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .CMsgEffectData effectdata = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEEffectDispatch, _impl_.effectdata_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgEffectData effectdata = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEEffectDispatch, _impl_.effectdata_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgEffectData>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEEffectDispatch::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEffectDispatch)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgEffectData effectdata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::effectdata(this),
        _Internal::effectdata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEffectDispatch)
  return target;
}

::size_t CMsgTEEffectDispatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEffectDispatch)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgEffectData effectdata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.effectdata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEEffectDispatch::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEEffectDispatch::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEEffectDispatch::GetClassData() const { return &_class_data_; }


void CMsgTEEffectDispatch::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEEffectDispatch*>(&to_msg);
  auto& from = static_cast<const CMsgTEEffectDispatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEffectDispatch)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_effectdata()->::CMsgEffectData::MergeFrom(
        from._internal_effectdata());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEEffectDispatch::CopyFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEEffectDispatch::IsInitialized() const {
  return true;
}

void CMsgTEEffectDispatch::InternalSwap(CMsgTEEffectDispatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.effectdata_, other->_impl_.effectdata_);
}

::google::protobuf::Metadata CMsgTEEffectDispatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[11]);
}
// ===================================================================

class CMsgTEEnergySplash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEnergySplash>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEEnergySplash* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEEnergySplash* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_explosive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector& CMsgTEEnergySplash::_Internal::pos(const CMsgTEEnergySplash* msg) {
  return *msg->_impl_.pos_;
}
const ::CMsgVector& CMsgTEEnergySplash::_Internal::dir(const CMsgTEEnergySplash* msg) {
  return *msg->_impl_.dir_;
}
void CMsgTEEnergySplash::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEnergySplash::clear_dir() {
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEEnergySplash::CMsgTEEnergySplash(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEnergySplash)
}
CMsgTEEnergySplash::CMsgTEEnergySplash(const CMsgTEEnergySplash& from) : ::google::protobuf::Message() {
  CMsgTEEnergySplash* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.pos_){nullptr},
      decltype(_impl_.dir_){nullptr},
      decltype(_impl_.explosive_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dir_ = new ::CMsgVector(*from._impl_.dir_);
  }
  _this->_impl_.explosive_ = from._impl_.explosive_;

  // @@protoc_insertion_point(copy_constructor:CMsgTEEnergySplash)
}
inline void CMsgTEEnergySplash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.pos_){nullptr},
      decltype(_impl_.dir_){nullptr},
      decltype(_impl_.explosive_){false},
  };
}
CMsgTEEnergySplash::~CMsgTEEnergySplash() {
  // @@protoc_insertion_point(destructor:CMsgTEEnergySplash)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEEnergySplash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.dir_;
}
void CMsgTEEnergySplash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEEnergySplash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEnergySplash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.dir_ != nullptr);
      _impl_.dir_->Clear();
    }
  }
  _impl_.explosive_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEEnergySplash::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CMsgTEEnergySplash::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEEnergySplash_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector pos = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.pos_)}},
    // optional .CMsgVector dir = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.dir_)}},
    // optional bool explosive = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CMsgTEEnergySplash, _impl_.explosive_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.explosive_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector pos = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.pos_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector dir = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.dir_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool explosive = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.explosive_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEEnergySplash::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEnergySplash)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dir(this),
        _Internal::dir(this).GetCachedSize(), target, stream);
  }

  // optional bool explosive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_explosive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEnergySplash)
  return target;
}

::size_t CMsgTEEnergySplash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEnergySplash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.dir_);
    }

    // optional bool explosive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEEnergySplash::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEEnergySplash::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEEnergySplash::GetClassData() const { return &_class_data_; }


void CMsgTEEnergySplash::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEEnergySplash*>(&to_msg);
  auto& from = static_cast<const CMsgTEEnergySplash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEnergySplash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dir()->::CMsgVector::MergeFrom(
          from._internal_dir());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.explosive_ = from._impl_.explosive_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEEnergySplash::CopyFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEEnergySplash::IsInitialized() const {
  return true;
}

void CMsgTEEnergySplash::InternalSwap(CMsgTEEnergySplash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.explosive_)
      + sizeof(CMsgTEEnergySplash::_impl_.explosive_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::google::protobuf::Metadata CMsgTEEnergySplash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[12]);
}
// ===================================================================

class CMsgTEFizz::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEFizz>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_._has_bits_);
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_density(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgTEFizz::CMsgTEFizz(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEFizz)
}
CMsgTEFizz::CMsgTEFizz(const CMsgTEFizz& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgTEFizz)
}
inline void CMsgTEFizz::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.density_){0u},
      decltype(_impl_.current_){0},
      decltype(_impl_.entity_){-1},
  };
}
CMsgTEFizz::~CMsgTEFizz() {
  // @@protoc_insertion_point(destructor:CMsgTEFizz)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEFizz::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void CMsgTEFizz::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEFizz::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEFizz)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.density_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.current_) -
        reinterpret_cast<char*>(&_impl_.density_)) + sizeof(_impl_.current_));
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEFizz::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> CMsgTEFizz::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CMsgTEFizz_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 entity = 1 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEFizz, _impl_.entity_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.entity_)}},
    // optional uint32 density = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEFizz, _impl_.density_), 0>(),
     {16, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.density_)}},
    // optional int32 current = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEFizz, _impl_.current_), 1>(),
     {24, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.current_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 entity = 1 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.entity_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 density = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.density_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 current = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.current_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CMsgTEFizz::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEFizz)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_entity(), target);
  }

  // optional uint32 density = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_density(), target);
  }

  // optional int32 current = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_current(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEFizz)
  return target;
}

::size_t CMsgTEFizz::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEFizz)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 density = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_density());
    }

    // optional int32 current = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_current());
    }

    // optional int32 entity = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEFizz::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEFizz::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEFizz::GetClassData() const { return &_class_data_; }


void CMsgTEFizz::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEFizz*>(&to_msg);
  auto& from = static_cast<const CMsgTEFizz&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEFizz)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.density_ = from._impl_.density_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.current_ = from._impl_.current_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEFizz::CopyFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEFizz::IsInitialized() const {
  return true;
}

void CMsgTEFizz::InternalSwap(CMsgTEFizz* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.entity_)
      + sizeof(CMsgTEFizz::_impl_.entity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.density_)>(
          reinterpret_cast<char*>(&_impl_.density_),
          reinterpret_cast<char*>(&other->_impl_.density_));
}

::google::protobuf::Metadata CMsgTEFizz::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[13]);
}
// ===================================================================

class CMsgTEShatterSurface::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEShatterSurface>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEShatterSurface* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEShatterSurface* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& force(const CMsgTEShatterSurface* msg);
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& forcepos(const CMsgTEShatterSurface* msg);
  static void set_has_forcepos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shardsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surfacetype(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_frontcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_backcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CMsgVector& CMsgTEShatterSurface::_Internal::origin(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle& CMsgTEShatterSurface::_Internal::angles(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.angles_;
}
const ::CMsgVector& CMsgTEShatterSurface::_Internal::force(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.force_;
}
const ::CMsgVector& CMsgTEShatterSurface::_Internal::forcepos(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.forcepos_;
}
void CMsgTEShatterSurface::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEShatterSurface::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEShatterSurface::clear_force() {
  if (_impl_.force_ != nullptr) _impl_.force_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgTEShatterSurface::clear_forcepos() {
  if (_impl_.forcepos_ != nullptr) _impl_.forcepos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgTEShatterSurface::CMsgTEShatterSurface(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEShatterSurface)
}
CMsgTEShatterSurface::CMsgTEShatterSurface(const CMsgTEShatterSurface& from) : ::google::protobuf::Message() {
  CMsgTEShatterSurface* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.force_){nullptr},
      decltype(_impl_.forcepos_){nullptr},
      decltype(_impl_.width_){},
      decltype(_impl_.height_){},
      decltype(_impl_.shardsize_){},
      decltype(_impl_.surfacetype_){},
      decltype(_impl_.frontcolor_){},
      decltype(_impl_.backcolor_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.force_ = new ::CMsgVector(*from._impl_.force_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.forcepos_ = new ::CMsgVector(*from._impl_.forcepos_);
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.backcolor_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.backcolor_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEShatterSurface)
}
inline void CMsgTEShatterSurface::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.force_){nullptr},
      decltype(_impl_.forcepos_){nullptr},
      decltype(_impl_.width_){0},
      decltype(_impl_.height_){0},
      decltype(_impl_.shardsize_){0},
      decltype(_impl_.surfacetype_){0u},
      decltype(_impl_.frontcolor_){0u},
      decltype(_impl_.backcolor_){0u},
  };
}
CMsgTEShatterSurface::~CMsgTEShatterSurface() {
  // @@protoc_insertion_point(destructor:CMsgTEShatterSurface)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEShatterSurface::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
  if (this != internal_default_instance()) delete _impl_.force_;
  if (this != internal_default_instance()) delete _impl_.forcepos_;
}
void CMsgTEShatterSurface::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEShatterSurface::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEShatterSurface)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.force_ != nullptr);
      _impl_.force_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.forcepos_ != nullptr);
      _impl_.forcepos_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.width_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.surfacetype_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.surfacetype_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.frontcolor_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.backcolor_) -
        reinterpret_cast<char*>(&_impl_.frontcolor_)) + sizeof(_impl_.backcolor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEShatterSurface::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 4, 0, 2> CMsgTEShatterSurface::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEShatterSurface_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.origin_)}},
    // optional .CMsgQAngle angles = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.angles_)}},
    // optional .CMsgVector force = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.force_)}},
    // optional .CMsgVector forcepos = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.forcepos_)}},
    // optional float width = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.width_)}},
    // optional float height = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.height_)}},
    // optional float shardsize = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.shardsize_)}},
    // optional uint32 surfacetype = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEShatterSurface, _impl_.surfacetype_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.surfacetype_)}},
    // optional fixed32 frontcolor = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.frontcolor_)}},
    // optional fixed32 backcolor = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0, PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.backcolor_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgQAngle angles = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.angles_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector force = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.force_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector forcepos = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.forcepos_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float width = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.width_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float height = 6;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.height_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float shardsize = 7;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.shardsize_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 surfacetype = 8;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.surfacetype_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional fixed32 frontcolor = 9;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.frontcolor_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 backcolor = 10;
    {PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.backcolor_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgQAngle>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEShatterSurface::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEShatterSurface)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector force = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::force(this),
        _Internal::force(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector forcepos = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::forcepos(this),
        _Internal::forcepos(this).GetCachedSize(), target, stream);
  }

  // optional float width = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_width(), target);
  }

  // optional float height = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_height(), target);
  }

  // optional float shardsize = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_shardsize(), target);
  }

  // optional uint32 surfacetype = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_surfacetype(), target);
  }

  // optional fixed32 frontcolor = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        9, this->_internal_frontcolor(), target);
  }

  // optional fixed32 backcolor = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        10, this->_internal_backcolor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEShatterSurface)
  return target;
}

::size_t CMsgTEShatterSurface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEShatterSurface)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional .CMsgVector force = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.force_);
    }

    // optional .CMsgVector forcepos = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.forcepos_);
    }

    // optional float width = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // optional float height = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // optional float shardsize = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 5;
    }

    // optional uint32 surfacetype = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_surfacetype());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional fixed32 frontcolor = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // optional fixed32 backcolor = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEShatterSurface::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEShatterSurface::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEShatterSurface::GetClassData() const { return &_class_data_; }


void CMsgTEShatterSurface::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEShatterSurface*>(&to_msg);
  auto& from = static_cast<const CMsgTEShatterSurface&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEShatterSurface)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_force()->::CMsgVector::MergeFrom(
          from._internal_force());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_forcepos()->::CMsgVector::MergeFrom(
          from._internal_forcepos());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shardsize_ = from._impl_.shardsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.surfacetype_ = from._impl_.surfacetype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.frontcolor_ = from._impl_.frontcolor_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.backcolor_ = from._impl_.backcolor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEShatterSurface::CopyFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEShatterSurface::IsInitialized() const {
  return true;
}

void CMsgTEShatterSurface::InternalSwap(CMsgTEShatterSurface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.backcolor_)
      + sizeof(CMsgTEShatterSurface::_impl_.backcolor_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEShatterSurface::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[14]);
}
// ===================================================================

class CMsgTEGlowSprite::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEGlowSprite>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEGlowSprite* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEGlowSprite::_Internal::origin(const CMsgTEGlowSprite* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTEGlowSprite::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTEGlowSprite::CMsgTEGlowSprite(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEGlowSprite)
}
CMsgTEGlowSprite::CMsgTEGlowSprite(const CMsgTEGlowSprite& from) : ::google::protobuf::Message() {
  CMsgTEGlowSprite* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.scale_){},
      decltype(_impl_.life_){},
      decltype(_impl_.brightness_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.brightness_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.brightness_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEGlowSprite)
}
inline void CMsgTEGlowSprite::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.scale_){0},
      decltype(_impl_.life_){0},
      decltype(_impl_.brightness_){0u},
  };
}
CMsgTEGlowSprite::~CMsgTEGlowSprite() {
  // @@protoc_insertion_point(destructor:CMsgTEGlowSprite)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEGlowSprite::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}
void CMsgTEGlowSprite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEGlowSprite::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEGlowSprite)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.scale_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.brightness_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.brightness_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEGlowSprite::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CMsgTEGlowSprite::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEGlowSprite_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional uint32 brightness = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEGlowSprite, _impl_.brightness_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.brightness_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.origin_)}},
    // optional float scale = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.scale_)}},
    // optional float life = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.life_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float scale = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.scale_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float life = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.life_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 brightness = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.brightness_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEGlowSprite::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEGlowSprite)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_scale(), target);
  }

  // optional float life = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_life(), target);
  }

  // optional uint32 brightness = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_brightness(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEGlowSprite)
  return target;
}

::size_t CMsgTEGlowSprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEGlowSprite)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

    // optional float life = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional uint32 brightness = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_brightness());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEGlowSprite::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEGlowSprite::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEGlowSprite::GetClassData() const { return &_class_data_; }


void CMsgTEGlowSprite::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEGlowSprite*>(&to_msg);
  auto& from = static_cast<const CMsgTEGlowSprite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEGlowSprite)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.life_ = from._impl_.life_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.brightness_ = from._impl_.brightness_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEGlowSprite::CopyFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEGlowSprite::IsInitialized() const {
  return true;
}

void CMsgTEGlowSprite::InternalSwap(CMsgTEGlowSprite* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.brightness_)
      + sizeof(CMsgTEGlowSprite::_impl_.brightness_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEGlowSprite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[15]);
}
// ===================================================================

class CMsgTEImpact::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEImpact>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEImpact* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEImpact* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector& CMsgTEImpact::_Internal::origin(const CMsgTEImpact* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEImpact::_Internal::normal(const CMsgTEImpact* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEImpact::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEImpact::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEImpact::CMsgTEImpact(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEImpact)
}
CMsgTEImpact::CMsgTEImpact(const CMsgTEImpact& from) : ::google::protobuf::Message() {
  CMsgTEImpact* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.type_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  _this->_impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:CMsgTEImpact)
}
inline void CMsgTEImpact::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.type_){0u},
  };
}
CMsgTEImpact::~CMsgTEImpact() {
  // @@protoc_insertion_point(destructor:CMsgTEImpact)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEImpact::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}
void CMsgTEImpact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEImpact::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEImpact)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEImpact::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CMsgTEImpact::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEImpact_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.origin_)}},
    // optional .CMsgVector normal = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.normal_)}},
    // optional uint32 type = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEImpact, _impl_.type_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector normal = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.normal_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 type = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.type_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEImpact::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEImpact)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEImpact)
  return target;
}

::size_t CMsgTEImpact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEImpact)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEImpact::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEImpact::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEImpact::GetClassData() const { return &_class_data_; }


void CMsgTEImpact::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEImpact*>(&to_msg);
  auto& from = static_cast<const CMsgTEImpact&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEImpact)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEImpact::CopyFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEImpact::IsInitialized() const {
  return true;
}

void CMsgTEImpact::InternalSwap(CMsgTEImpact* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.type_)
      + sizeof(CMsgTEImpact::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEImpact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[16]);
}
// ===================================================================

class CMsgTEMuzzleFlash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEMuzzleFlash>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEMuzzleFlash* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEMuzzleFlash* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEMuzzleFlash::_Internal::origin(const CMsgTEMuzzleFlash* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle& CMsgTEMuzzleFlash::_Internal::angles(const CMsgTEMuzzleFlash* msg) {
  return *msg->_impl_.angles_;
}
void CMsgTEMuzzleFlash::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEMuzzleFlash::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEMuzzleFlash)
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from) : ::google::protobuf::Message() {
  CMsgTEMuzzleFlash* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.scale_){},
      decltype(_impl_.type_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.type_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEMuzzleFlash)
}
inline void CMsgTEMuzzleFlash::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.scale_){0},
      decltype(_impl_.type_){0u},
  };
}
CMsgTEMuzzleFlash::~CMsgTEMuzzleFlash() {
  // @@protoc_insertion_point(destructor:CMsgTEMuzzleFlash)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEMuzzleFlash::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}
void CMsgTEMuzzleFlash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEMuzzleFlash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEMuzzleFlash)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.scale_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEMuzzleFlash::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> CMsgTEMuzzleFlash::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEMuzzleFlash_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional uint32 type = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEMuzzleFlash, _impl_.type_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.type_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.origin_)}},
    // optional .CMsgQAngle angles = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.angles_)}},
    // optional float scale = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.scale_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgQAngle angles = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.angles_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float scale = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.scale_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional uint32 type = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.type_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgQAngle>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEMuzzleFlash::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEMuzzleFlash)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_scale(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEMuzzleFlash)
  return target;
}

::size_t CMsgTEMuzzleFlash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEMuzzleFlash)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional float scale = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEMuzzleFlash::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEMuzzleFlash::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEMuzzleFlash::GetClassData() const { return &_class_data_; }


void CMsgTEMuzzleFlash::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEMuzzleFlash*>(&to_msg);
  auto& from = static_cast<const CMsgTEMuzzleFlash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEMuzzleFlash)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEMuzzleFlash::CopyFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEMuzzleFlash::IsInitialized() const {
  return true;
}

void CMsgTEMuzzleFlash::InternalSwap(CMsgTEMuzzleFlash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.type_)
      + sizeof(CMsgTEMuzzleFlash::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEMuzzleFlash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[17]);
}
// ===================================================================

class CMsgTEBloodStream::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBloodStream>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBloodStream* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& direction(const CMsgTEBloodStream* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEBloodStream::_Internal::origin(const CMsgTEBloodStream* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEBloodStream::_Internal::direction(const CMsgTEBloodStream* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTEBloodStream::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBloodStream::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBloodStream::CMsgTEBloodStream(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBloodStream)
}
CMsgTEBloodStream::CMsgTEBloodStream(const CMsgTEBloodStream& from) : ::google::protobuf::Message() {
  CMsgTEBloodStream* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.color_){},
      decltype(_impl_.amount_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.color_, &from._impl_.color_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.amount_) -
    reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.amount_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEBloodStream)
}
inline void CMsgTEBloodStream::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.color_){0u},
      decltype(_impl_.amount_){0u},
  };
}
CMsgTEBloodStream::~CMsgTEBloodStream() {
  // @@protoc_insertion_point(destructor:CMsgTEBloodStream)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEBloodStream::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}
void CMsgTEBloodStream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEBloodStream::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBloodStream)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.color_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.amount_) -
        reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.amount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEBloodStream::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> CMsgTEBloodStream::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEBloodStream_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional uint32 amount = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEBloodStream, _impl_.amount_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.amount_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.origin_)}},
    // optional .CMsgVector direction = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.direction_)}},
    // optional fixed32 color = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.color_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector direction = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.direction_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional fixed32 color = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.color_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 amount = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.amount_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEBloodStream::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBloodStream)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        3, this->_internal_color(), target);
  }

  // optional uint32 amount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBloodStream)
  return target;
}

::size_t CMsgTEBloodStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBloodStream)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional fixed32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional uint32 amount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_amount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEBloodStream::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEBloodStream::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEBloodStream::GetClassData() const { return &_class_data_; }


void CMsgTEBloodStream::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBloodStream*>(&to_msg);
  auto& from = static_cast<const CMsgTEBloodStream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBloodStream)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBloodStream::CopyFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEBloodStream::IsInitialized() const {
  return true;
}

void CMsgTEBloodStream::InternalSwap(CMsgTEBloodStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.amount_)
      + sizeof(CMsgTEBloodStream::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEBloodStream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[18]);
}
// ===================================================================

class CMsgTEExplosion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEExplosion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEExplosion* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& normal(const CMsgTEExplosion* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_materialtype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_affect_ragdolls(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_effect_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_explosion_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CMsgVector& CMsgTEExplosion::_Internal::origin(const CMsgTEExplosion* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEExplosion::_Internal::normal(const CMsgTEExplosion* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEExplosion::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEExplosion::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEExplosion::CMsgTEExplosion(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEExplosion)
}
CMsgTEExplosion::CMsgTEExplosion(const CMsgTEExplosion& from) : ::google::protobuf::Message() {
  CMsgTEExplosion* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.effect_name_){},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.framerate_){},
      decltype(_impl_.flags_){},
      decltype(_impl_.materialtype_){},
      decltype(_impl_.radius_){},
      decltype(_impl_.magnitude_){},
      decltype(_impl_.scale_){},
      decltype(_impl_.affect_ragdolls_){},
      decltype(_impl_.explosion_type_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.effect_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.effect_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.effect_name_.Set(from._internal_effect_name(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  ::memcpy(&_impl_.framerate_, &from._impl_.framerate_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.explosion_type_) -
    reinterpret_cast<char*>(&_impl_.framerate_)) + sizeof(_impl_.explosion_type_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEExplosion)
}
inline void CMsgTEExplosion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.effect_name_){},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.framerate_){0u},
      decltype(_impl_.flags_){0u},
      decltype(_impl_.materialtype_){0u},
      decltype(_impl_.radius_){0u},
      decltype(_impl_.magnitude_){0u},
      decltype(_impl_.scale_){0},
      decltype(_impl_.affect_ragdolls_){false},
      decltype(_impl_.explosion_type_){0u},
  };
  _impl_.effect_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.effect_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}
CMsgTEExplosion::~CMsgTEExplosion() {
  // @@protoc_insertion_point(destructor:CMsgTEExplosion)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEExplosion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.effect_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}
void CMsgTEExplosion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEExplosion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEExplosion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.effect_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.framerate_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.magnitude_) -
        reinterpret_cast<char*>(&_impl_.framerate_)) + sizeof(_impl_.magnitude_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.scale_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.explosion_type_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.explosion_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEExplosion::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 2, 43, 2> CMsgTEExplosion::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEExplosion_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.origin_)}},
    // optional uint32 framerate = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.framerate_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.framerate_)}},
    // optional uint32 flags = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.flags_), 4>(),
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.flags_)}},
    // optional .CMsgVector normal = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 1, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.normal_)}},
    // optional uint32 materialtype = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.materialtype_), 5>(),
     {40, 5, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.materialtype_)}},
    // optional uint32 radius = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.radius_), 6>(),
     {48, 6, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.radius_)}},
    // optional uint32 magnitude = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.magnitude_), 7>(),
     {56, 7, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.magnitude_)}},
    // optional float scale = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 8, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.scale_)}},
    // optional bool affect_ragdolls = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CMsgTEExplosion, _impl_.affect_ragdolls_), 9>(),
     {72, 9, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.affect_ragdolls_)}},
    // optional string effect_name = 10;
    {::_pbi::TcParser::FastSS1,
     {82, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.effect_name_)}},
    // optional uint32 explosion_type = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEExplosion, _impl_.explosion_type_), 10>(),
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.explosion_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.origin_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 framerate = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.framerate_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 flags = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.flags_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .CMsgVector normal = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.normal_), _Internal::kHasBitsOffset + 2, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 materialtype = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.materialtype_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 radius = 6;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.radius_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 magnitude = 7;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.magnitude_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float scale = 8;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.scale_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional bool affect_ragdolls = 9;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.affect_ragdolls_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string effect_name = 10;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.effect_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kRawString | ::_fl::kRepAString)},
    // optional uint32 explosion_type = 11;
    {PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.explosion_type_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
    "\17\0\0\0\0\0\0\0\0\0\13\0\0\0\0\0"
    "CMsgTEExplosion"
    "effect_name"
  }},
};

::uint8_t* CMsgTEExplosion::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEExplosion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_framerate(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_flags(), target);
  }

  // optional .CMsgVector normal = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 materialtype = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_materialtype(), target);
  }

  // optional uint32 radius = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_radius(), target);
  }

  // optional uint32 magnitude = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_magnitude(), target);
  }

  // optional float scale = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_scale(), target);
  }

  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_affect_ragdolls(), target);
  }

  // optional string effect_name = 10;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_effect_name();
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormat::SERIALIZE,
                                "CMsgTEExplosion.effect_name");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // optional uint32 explosion_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_explosion_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEExplosion)
  return target;
}

::size_t CMsgTEExplosion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEExplosion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string effect_name = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_effect_name());
    }

    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_framerate());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 materialtype = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_materialtype());
    }

    // optional uint32 radius = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_radius());
    }

    // optional uint32 magnitude = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_magnitude());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float scale = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // optional bool affect_ragdolls = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2;
    }

    // optional uint32 explosion_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_explosion_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEExplosion::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEExplosion::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEExplosion::GetClassData() const { return &_class_data_; }


void CMsgTEExplosion::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEExplosion*>(&to_msg);
  auto& from = static_cast<const CMsgTEExplosion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEExplosion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_effect_name(from._internal_effect_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.framerate_ = from._impl_.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.materialtype_ = from._impl_.materialtype_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.affect_ragdolls_ = from._impl_.affect_ragdolls_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.explosion_type_ = from._impl_.explosion_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEExplosion::CopyFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEExplosion::IsInitialized() const {
  return true;
}

void CMsgTEExplosion::InternalSwap(CMsgTEExplosion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.effect_name_, lhs_arena,
                                       &other->_impl_.effect_name_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.explosion_type_)
      + sizeof(CMsgTEExplosion::_impl_.explosion_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEExplosion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[19]);
}
// ===================================================================

class CMsgTEDust::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDust>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDust* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTEDust* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector& CMsgTEDust::_Internal::origin(const CMsgTEDust* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEDust::_Internal::direction(const CMsgTEDust* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTEDust::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDust::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEDust::CMsgTEDust(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDust)
}
CMsgTEDust::CMsgTEDust(const CMsgTEDust& from) : ::google::protobuf::Message() {
  CMsgTEDust* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.size_){},
      decltype(_impl_.speed_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEDust)
}
inline void CMsgTEDust::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.size_){0},
      decltype(_impl_.speed_){0},
  };
}
CMsgTEDust::~CMsgTEDust() {
  // @@protoc_insertion_point(destructor:CMsgTEDust)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEDust::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}
void CMsgTEDust::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEDust::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDust)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEDust::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> CMsgTEDust::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEDust_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .CMsgVector direction = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.direction_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.origin_)}},
    // optional float size = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.size_)}},
    // optional float speed = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.speed_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float size = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.size_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float speed = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.speed_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional .CMsgVector direction = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.direction_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEDust::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDust)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_size(), target);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_speed(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDust)
  return target;
}

::size_t CMsgTEDust::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDust)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional float size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 5;
    }

    // optional float speed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEDust::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEDust::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEDust::GetClassData() const { return &_class_data_; }


void CMsgTEDust::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEDust*>(&to_msg);
  auto& from = static_cast<const CMsgTEDust&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDust)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEDust::CopyFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEDust::IsInitialized() const {
  return true;
}

void CMsgTEDust::InternalSwap(CMsgTEDust* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.speed_)
      + sizeof(CMsgTEDust::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEDust::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[20]);
}
// ===================================================================

class CMsgTELargeFunnel::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTELargeFunnel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTELargeFunnel* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reversed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector& CMsgTELargeFunnel::_Internal::origin(const CMsgTELargeFunnel* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTELargeFunnel::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTELargeFunnel::CMsgTELargeFunnel(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTELargeFunnel)
}
CMsgTELargeFunnel::CMsgTELargeFunnel(const CMsgTELargeFunnel& from) : ::google::protobuf::Message() {
  CMsgTELargeFunnel* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.reversed_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  _this->_impl_.reversed_ = from._impl_.reversed_;

  // @@protoc_insertion_point(copy_constructor:CMsgTELargeFunnel)
}
inline void CMsgTELargeFunnel::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.reversed_){0u},
  };
}
CMsgTELargeFunnel::~CMsgTELargeFunnel() {
  // @@protoc_insertion_point(destructor:CMsgTELargeFunnel)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTELargeFunnel::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}
void CMsgTELargeFunnel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTELargeFunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTELargeFunnel)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  _impl_.reversed_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTELargeFunnel::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> CMsgTELargeFunnel::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTELargeFunnel_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional uint32 reversed = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTELargeFunnel, _impl_.reversed_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.reversed_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.origin_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 reversed = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.reversed_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTELargeFunnel::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTELargeFunnel)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 reversed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_reversed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTELargeFunnel)
  return target;
}

::size_t CMsgTELargeFunnel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTELargeFunnel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional uint32 reversed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_reversed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTELargeFunnel::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTELargeFunnel::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTELargeFunnel::GetClassData() const { return &_class_data_; }


void CMsgTELargeFunnel::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTELargeFunnel*>(&to_msg);
  auto& from = static_cast<const CMsgTELargeFunnel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTELargeFunnel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.reversed_ = from._impl_.reversed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTELargeFunnel::CopyFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTELargeFunnel::IsInitialized() const {
  return true;
}

void CMsgTELargeFunnel::InternalSwap(CMsgTELargeFunnel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.reversed_)
      + sizeof(CMsgTELargeFunnel::_impl_.reversed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTELargeFunnel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[21]);
}
// ===================================================================

class CMsgTESparks::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESparks>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESparks* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTESparks* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector& CMsgTESparks::_Internal::origin(const CMsgTESparks* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTESparks::_Internal::direction(const CMsgTESparks* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTESparks::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTESparks::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTESparks::CMsgTESparks(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTESparks)
}
CMsgTESparks::CMsgTESparks(const CMsgTESparks& from) : ::google::protobuf::Message() {
  CMsgTESparks* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.magnitude_){},
      decltype(_impl_.length_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.magnitude_, &from._impl_.magnitude_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.length_) -
    reinterpret_cast<char*>(&_impl_.magnitude_)) + sizeof(_impl_.length_));

  // @@protoc_insertion_point(copy_constructor:CMsgTESparks)
}
inline void CMsgTESparks::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.direction_){nullptr},
      decltype(_impl_.magnitude_){0u},
      decltype(_impl_.length_){0u},
  };
}
CMsgTESparks::~CMsgTESparks() {
  // @@protoc_insertion_point(destructor:CMsgTESparks)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTESparks::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}
void CMsgTESparks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTESparks::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESparks)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.magnitude_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.magnitude_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTESparks::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> CMsgTESparks::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTESparks_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .CMsgVector direction = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.direction_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.origin_)}},
    // optional uint32 magnitude = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTESparks, _impl_.magnitude_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.magnitude_)}},
    // optional uint32 length = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTESparks, _impl_.length_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.length_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 magnitude = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.magnitude_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 length = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.length_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .CMsgVector direction = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.direction_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTESparks::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESparks)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 magnitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_magnitude(), target);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_length(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESparks)
  return target;
}

::size_t CMsgTESparks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESparks)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional uint32 magnitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_magnitude());
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTESparks::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTESparks::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTESparks::GetClassData() const { return &_class_data_; }


void CMsgTESparks::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTESparks*>(&to_msg);
  auto& from = static_cast<const CMsgTESparks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESparks)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTESparks::CopyFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTESparks::IsInitialized() const {
  return true;
}

void CMsgTESparks::InternalSwap(CMsgTESparks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.length_)
      + sizeof(CMsgTESparks::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTESparks::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[22]);
}
// ===================================================================

class CMsgTEPhysicsProp::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPhysicsProp>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPhysicsProp* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& velocity(const CMsgTEPhysicsProp* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEPhysicsProp* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skin(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_effects(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_unused_breakmodelsnottomake(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::CMsgVector& dmgpos(const CMsgTEPhysicsProp* msg);
  static void set_has_dmgpos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& dmgdir(const CMsgTEPhysicsProp* msg);
  static void set_has_dmgdir(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dmgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::CMsgVector& CMsgTEPhysicsProp::_Internal::origin(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEPhysicsProp::_Internal::velocity(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.velocity_;
}
const ::CMsgQAngle& CMsgTEPhysicsProp::_Internal::angles(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.angles_;
}
const ::CMsgVector& CMsgTEPhysicsProp::_Internal::dmgpos(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.dmgpos_;
}
const ::CMsgVector& CMsgTEPhysicsProp::_Internal::dmgdir(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.dmgdir_;
}
void CMsgTEPhysicsProp::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPhysicsProp::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPhysicsProp::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgTEPhysicsProp::clear_dmgpos() {
  if (_impl_.dmgpos_ != nullptr) _impl_.dmgpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CMsgTEPhysicsProp::clear_dmgdir() {
  if (_impl_.dmgdir_ != nullptr) _impl_.dmgdir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPhysicsProp)
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from) : ::google::protobuf::Message() {
  CMsgTEPhysicsProp* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.velocity_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.dmgpos_){nullptr},
      decltype(_impl_.dmgdir_){nullptr},
      decltype(_impl_.skin_){},
      decltype(_impl_.flags_){},
      decltype(_impl_.effects_){},
      decltype(_impl_.color_){},
      decltype(_impl_.modelindex_){},
      decltype(_impl_.unused_breakmodelsnottomake_){},
      decltype(_impl_.scale_){},
      decltype(_impl_.dmgtype_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.velocity_ = new ::CMsgVector(*from._impl_.velocity_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.dmgpos_ = new ::CMsgVector(*from._impl_.dmgpos_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.dmgdir_ = new ::CMsgVector(*from._impl_.dmgdir_);
  }
  ::memcpy(&_impl_.skin_, &from._impl_.skin_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.dmgtype_) -
    reinterpret_cast<char*>(&_impl_.skin_)) + sizeof(_impl_.dmgtype_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEPhysicsProp)
}
inline void CMsgTEPhysicsProp::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.velocity_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.dmgpos_){nullptr},
      decltype(_impl_.dmgdir_){nullptr},
      decltype(_impl_.skin_){0u},
      decltype(_impl_.flags_){0u},
      decltype(_impl_.effects_){0u},
      decltype(_impl_.color_){0u},
      decltype(_impl_.modelindex_){::uint64_t{0u}},
      decltype(_impl_.unused_breakmodelsnottomake_){0u},
      decltype(_impl_.scale_){0},
      decltype(_impl_.dmgtype_){0},
  };
}
CMsgTEPhysicsProp::~CMsgTEPhysicsProp() {
  // @@protoc_insertion_point(destructor:CMsgTEPhysicsProp)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEPhysicsProp::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.angles_;
  if (this != internal_default_instance()) delete _impl_.dmgpos_;
  if (this != internal_default_instance()) delete _impl_.dmgdir_;
}
void CMsgTEPhysicsProp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEPhysicsProp::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPhysicsProp)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.dmgpos_ != nullptr);
      _impl_.dmgpos_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.dmgdir_ != nullptr);
      _impl_.dmgdir_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.skin_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.effects_) -
        reinterpret_cast<char*>(&_impl_.skin_)) + sizeof(_impl_.effects_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.color_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dmgtype_) -
        reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.dmgtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEPhysicsProp::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 5, 0, 2> CMsgTEPhysicsProp::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEPhysicsProp_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.origin_)}},
    // optional .CMsgVector velocity = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.velocity_)}},
    // optional .CMsgQAngle angles = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.angles_)}},
    // optional fixed32 skin = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 5, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.skin_)}},
    // optional uint32 flags = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPhysicsProp, _impl_.flags_), 6>(),
     {40, 6, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.flags_)}},
    // optional uint32 effects = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPhysicsProp, _impl_.effects_), 7>(),
     {48, 7, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.effects_)}},
    // optional fixed32 color = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 8, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.color_)}},
    // optional fixed64 modelindex = 8;
    {::_pbi::TcParser::FastF64S1,
     {65, 9, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.modelindex_)}},
    // optional uint32 unused_breakmodelsnottomake = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPhysicsProp, _impl_.unused_breakmodelsnottomake_), 10>(),
     {72, 10, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.unused_breakmodelsnottomake_)}},
    // optional float scale = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 11, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.scale_)}},
    // optional .CMsgVector dmgpos = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 3, 3, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgpos_)}},
    // optional .CMsgVector dmgdir = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 4, 4, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgdir_)}},
    // optional int32 dmgtype = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPhysicsProp, _impl_.dmgtype_), 12>(),
     {104, 12, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgtype_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector velocity = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.velocity_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgQAngle angles = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.angles_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional fixed32 skin = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.skin_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 flags = 5;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.flags_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 effects = 6;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.effects_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional fixed32 color = 7;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.color_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed64 modelindex = 8;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.modelindex_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // optional uint32 unused_breakmodelsnottomake = 9;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.unused_breakmodelsnottomake_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float scale = 10;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.scale_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional .CMsgVector dmgpos = 11;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgpos_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector dmgdir = 12;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgdir_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 dmgtype = 13;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgtype_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgQAngle>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEPhysicsProp::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPhysicsProp)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 skin = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        4, this->_internal_skin(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_flags(), target);
  }

  // optional uint32 effects = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_effects(), target);
  }

  // optional fixed32 color = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        7, this->_internal_color(), target);
  }

  // optional fixed64 modelindex = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        8, this->_internal_modelindex(), target);
  }

  // optional uint32 unused_breakmodelsnottomake = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_unused_breakmodelsnottomake(), target);
  }

  // optional float scale = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_scale(), target);
  }

  // optional .CMsgVector dmgpos = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::dmgpos(this),
        _Internal::dmgpos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dmgdir = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::dmgdir(this),
        _Internal::dmgdir(this).GetCachedSize(), target, stream);
  }

  // optional int32 dmgtype = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<13>(
            stream, this->_internal_dmgtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPhysicsProp)
  return target;
}

::size_t CMsgTEPhysicsProp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPhysicsProp)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // optional .CMsgQAngle angles = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional .CMsgVector dmgpos = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.dmgpos_);
    }

    // optional .CMsgVector dmgdir = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.dmgdir_);
    }

    // optional fixed32 skin = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 5;
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_flags());
    }

    // optional uint32 effects = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_effects());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional fixed32 color = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 5;
    }

    // optional fixed64 modelindex = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 9;
    }

    // optional uint32 unused_breakmodelsnottomake = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_unused_breakmodelsnottomake());
    }

    // optional float scale = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }

    // optional int32 dmgtype = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dmgtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEPhysicsProp::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEPhysicsProp::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEPhysicsProp::GetClassData() const { return &_class_data_; }


void CMsgTEPhysicsProp::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEPhysicsProp*>(&to_msg);
  auto& from = static_cast<const CMsgTEPhysicsProp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPhysicsProp)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_velocity()->::CMsgVector::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_dmgpos()->::CMsgVector::MergeFrom(
          from._internal_dmgpos());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_dmgdir()->::CMsgVector::MergeFrom(
          from._internal_dmgdir());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.skin_ = from._impl_.skin_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.effects_ = from._impl_.effects_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.modelindex_ = from._impl_.modelindex_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.unused_breakmodelsnottomake_ = from._impl_.unused_breakmodelsnottomake_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.dmgtype_ = from._impl_.dmgtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEPhysicsProp::CopyFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEPhysicsProp::IsInitialized() const {
  return true;
}

void CMsgTEPhysicsProp::InternalSwap(CMsgTEPhysicsProp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgtype_)
      + sizeof(CMsgTEPhysicsProp::_impl_.dmgtype_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEPhysicsProp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[23]);
}
// ===================================================================

class CMsgTEPlayerDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPlayerDecal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPlayerDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector& CMsgTEPlayerDecal::_Internal::origin(const CMsgTEPlayerDecal* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTEPlayerDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPlayerDecal)
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from) : ::google::protobuf::Message() {
  CMsgTEPlayerDecal* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.player_){},
      decltype(_impl_.entity_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  ::memcpy(&_impl_.player_, &from._impl_.player_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.player_)) + sizeof(_impl_.entity_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEPlayerDecal)
}
inline void CMsgTEPlayerDecal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.player_){-1},
      decltype(_impl_.entity_){-1},
  };
}
CMsgTEPlayerDecal::~CMsgTEPlayerDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEPlayerDecal)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEPlayerDecal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}
void CMsgTEPlayerDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEPlayerDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPlayerDecal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    _impl_.player_ = -1;
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEPlayerDecal::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CMsgTEPlayerDecal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEPlayerDecal_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.origin_)}},
    // optional int32 player = 2 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPlayerDecal, _impl_.player_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.player_)}},
    // optional int32 entity = 3 [default = -1];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEPlayerDecal, _impl_.entity_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.entity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 player = 2 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.player_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 entity = 3 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.entity_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEPlayerDecal::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPlayerDecal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional int32 player = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_player(), target);
  }

  // optional int32 entity = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_entity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPlayerDecal)
  return target;
}

::size_t CMsgTEPlayerDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPlayerDecal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional int32 player = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_player());
    }

    // optional int32 entity = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEPlayerDecal::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEPlayerDecal::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEPlayerDecal::GetClassData() const { return &_class_data_; }


void CMsgTEPlayerDecal::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEPlayerDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEPlayerDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPlayerDecal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_ = from._impl_.player_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEPlayerDecal::CopyFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEPlayerDecal::IsInitialized() const {
  return true;
}

void CMsgTEPlayerDecal::InternalSwap(CMsgTEPlayerDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.entity_)
      + sizeof(CMsgTEPlayerDecal::_impl_.entity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEPlayerDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[24]);
}
// ===================================================================

class CMsgTEProjectedDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEProjectedDecal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEProjectedDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEProjectedDecal* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector& CMsgTEProjectedDecal::_Internal::origin(const CMsgTEProjectedDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle& CMsgTEProjectedDecal::_Internal::angles(const CMsgTEProjectedDecal* msg) {
  return *msg->_impl_.angles_;
}
void CMsgTEProjectedDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEProjectedDecal::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEProjectedDecal)
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from) : ::google::protobuf::Message() {
  CMsgTEProjectedDecal* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.index_){},
      decltype(_impl_.distance_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.distance_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.distance_));

  // @@protoc_insertion_point(copy_constructor:CMsgTEProjectedDecal)
}
inline void CMsgTEProjectedDecal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.angles_){nullptr},
      decltype(_impl_.index_){0u},
      decltype(_impl_.distance_){0},
  };
}
CMsgTEProjectedDecal::~CMsgTEProjectedDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEProjectedDecal)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEProjectedDecal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}
void CMsgTEProjectedDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEProjectedDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEProjectedDecal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.index_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.distance_) -
        reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.distance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEProjectedDecal::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 0, 2> CMsgTEProjectedDecal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEProjectedDecal_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional float distance = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.distance_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.origin_)}},
    // optional .CMsgQAngle angles = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.angles_)}},
    // optional uint32 index = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEProjectedDecal, _impl_.index_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgQAngle angles = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.angles_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 index = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.index_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float distance = 4;
    {PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.distance_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgQAngle>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEProjectedDecal::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEProjectedDecal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_index(), target);
  }

  // optional float distance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEProjectedDecal)
  return target;
}

::size_t CMsgTEProjectedDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEProjectedDecal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_index());
    }

    // optional float distance = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEProjectedDecal::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEProjectedDecal::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEProjectedDecal::GetClassData() const { return &_class_data_; }


void CMsgTEProjectedDecal::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEProjectedDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEProjectedDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEProjectedDecal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEProjectedDecal::CopyFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEProjectedDecal::IsInitialized() const {
  return true;
}

void CMsgTEProjectedDecal::InternalSwap(CMsgTEProjectedDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.distance_)
      + sizeof(CMsgTEProjectedDecal::_impl_.distance_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEProjectedDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[25]);
}
// ===================================================================

class CMsgTESmoke::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESmoke>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESmoke* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector& CMsgTESmoke::_Internal::origin(const CMsgTESmoke* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTESmoke::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTESmoke::CMsgTESmoke(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTESmoke)
}
CMsgTESmoke::CMsgTESmoke(const CMsgTESmoke& from) : ::google::protobuf::Message() {
  CMsgTESmoke* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.scale_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  _this->_impl_.scale_ = from._impl_.scale_;

  // @@protoc_insertion_point(copy_constructor:CMsgTESmoke)
}
inline void CMsgTESmoke::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.scale_){0},
  };
}
CMsgTESmoke::~CMsgTESmoke() {
  // @@protoc_insertion_point(destructor:CMsgTESmoke)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTESmoke::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}
void CMsgTESmoke::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTESmoke::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESmoke)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  _impl_.scale_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTESmoke::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> CMsgTESmoke::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTESmoke_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional float scale = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.scale_)}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.origin_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional float scale = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.scale_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTESmoke::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESmoke)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESmoke)
  return target;
}

::size_t CMsgTESmoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESmoke)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTESmoke::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTESmoke::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTESmoke::GetClassData() const { return &_class_data_; }


void CMsgTESmoke::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTESmoke*>(&to_msg);
  auto& from = static_cast<const CMsgTESmoke&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESmoke)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTESmoke::CopyFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTESmoke::IsInitialized() const {
  return true;
}

void CMsgTESmoke::InternalSwap(CMsgTESmoke* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.scale_)
      + sizeof(CMsgTESmoke::_impl_.scale_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTESmoke::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[26]);
}
// ===================================================================

class CMsgTEWorldDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEWorldDecal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEWorldDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEWorldDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector& CMsgTEWorldDecal::_Internal::origin(const CMsgTEWorldDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector& CMsgTEWorldDecal::_Internal::normal(const CMsgTEWorldDecal* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEWorldDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEWorldDecal::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEWorldDecal::CMsgTEWorldDecal(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEWorldDecal)
}
CMsgTEWorldDecal::CMsgTEWorldDecal(const CMsgTEWorldDecal& from) : ::google::protobuf::Message() {
  CMsgTEWorldDecal* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.index_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  _this->_impl_.index_ = from._impl_.index_;

  // @@protoc_insertion_point(copy_constructor:CMsgTEWorldDecal)
}
inline void CMsgTEWorldDecal::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.origin_){nullptr},
      decltype(_impl_.normal_){nullptr},
      decltype(_impl_.index_){0u},
  };
}
CMsgTEWorldDecal::~CMsgTEWorldDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEWorldDecal)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CMsgTEWorldDecal::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}
void CMsgTEWorldDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void CMsgTEWorldDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEWorldDecal)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CMsgTEWorldDecal::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CMsgTEWorldDecal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CMsgTEWorldDecal_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional .CMsgVector origin = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.origin_)}},
    // optional .CMsgVector normal = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.normal_)}},
    // optional uint32 index = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CMsgTEWorldDecal, _impl_.index_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .CMsgVector origin = 1;
    {PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.origin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .CMsgVector normal = 2;
    {PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.normal_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 index = 3;
    {PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.index_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
    {::_pbi::TcParser::GetTable<::CMsgVector>()},
  }}, {{
  }},
};

::uint8_t* CMsgTEWorldDecal::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEWorldDecal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEWorldDecal)
  return target;
}

::size_t CMsgTEWorldDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEWorldDecal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CMsgTEWorldDecal::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    CMsgTEWorldDecal::MergeImpl
};
const ::google::protobuf::Message::ClassData*CMsgTEWorldDecal::GetClassData() const { return &_class_data_; }


void CMsgTEWorldDecal::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEWorldDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEWorldDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEWorldDecal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEWorldDecal::CopyFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CMsgTEWorldDecal::IsInitialized() const {
  return true;
}

void CMsgTEWorldDecal::InternalSwap(CMsgTEWorldDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.index_)
      + sizeof(CMsgTEWorldDecal::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::google::protobuf::Metadata CMsgTEWorldDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[27]);
}
// @@protoc_insertion_point(namespace_scope)
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
