// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fatdemo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_fatdemo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_fatdemo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_fatdemo_2eproto;
class MLDemoHeader;
struct MLDemoHeaderDefaultTypeInternal;
extern MLDemoHeaderDefaultTypeInternal _MLDemoHeader_default_instance_;
class MLDict;
struct MLDictDefaultTypeInternal;
extern MLDictDefaultTypeInternal _MLDict_default_instance_;
class MLEvent;
struct MLEventDefaultTypeInternal;
extern MLEventDefaultTypeInternal _MLEvent_default_instance_;
class MLGameState;
struct MLGameStateDefaultTypeInternal;
extern MLGameStateDefaultTypeInternal _MLGameState_default_instance_;
class MLMatchState;
struct MLMatchStateDefaultTypeInternal;
extern MLMatchStateDefaultTypeInternal _MLMatchState_default_instance_;
class MLPlayerState;
struct MLPlayerStateDefaultTypeInternal;
extern MLPlayerStateDefaultTypeInternal _MLPlayerState_default_instance_;
class MLRoundState;
struct MLRoundStateDefaultTypeInternal;
extern MLRoundStateDefaultTypeInternal _MLRoundState_default_instance_;
class MLTick;
struct MLTickDefaultTypeInternal;
extern MLTickDefaultTypeInternal _MLTick_default_instance_;
class MLWeaponState;
struct MLWeaponStateDefaultTypeInternal;
extern MLWeaponStateDefaultTypeInternal _MLWeaponState_default_instance_;
class VacNetShot;
struct VacNetShotDefaultTypeInternal;
extern VacNetShotDefaultTypeInternal _VacNetShot_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum EHitGroup : int {
  EHG_Generic = 0,
  EHG_Head = 1,
  EHG_Chest = 2,
  EHG_Stomach = 3,
  EHG_LeftArm = 4,
  EHG_RightArm = 5,
  EHG_LeftLeg = 6,
  EHG_RightLeg = 7,
  EHG_Gear = 8,
  EHG_Miss = 9,
};

bool EHitGroup_IsValid(int value);
constexpr EHitGroup EHitGroup_MIN = static_cast<EHitGroup>(0);
constexpr EHitGroup EHitGroup_MAX = static_cast<EHitGroup>(9);
constexpr int EHitGroup_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
EHitGroup_descriptor();
template <typename T>
const std::string& EHitGroup_Name(T value) {
  static_assert(std::is_same<T, EHitGroup>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EHitGroup_Name().");
  return EHitGroup_Name(static_cast<EHitGroup>(value));
}
template <>
inline const std::string& EHitGroup_Name(EHitGroup value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EHitGroup_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool EHitGroup_Parse(absl::string_view name, EHitGroup* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitGroup>(
      EHitGroup_descriptor(), name, value);
}
enum ETeam : int {
  ET_Unknown = 0,
  ET_Spectator = 1,
  ET_Terrorist = 2,
  ET_CT = 3,
};

bool ETeam_IsValid(int value);
constexpr ETeam ETeam_MIN = static_cast<ETeam>(0);
constexpr ETeam ETeam_MAX = static_cast<ETeam>(3);
constexpr int ETeam_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ETeam_descriptor();
template <typename T>
const std::string& ETeam_Name(T value) {
  static_assert(std::is_same<T, ETeam>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ETeam_Name().");
  return ETeam_Name(static_cast<ETeam>(value));
}
template <>
inline const std::string& ETeam_Name(ETeam value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ETeam_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ETeam_Parse(absl::string_view name, ETeam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETeam>(
      ETeam_descriptor(), name, value);
}
enum EWeaponType : int {
  EWT_Knife = 0,
  EWT_Pistol = 1,
  EWT_SubMachineGun = 2,
  EWT_Rifle = 3,
  EWT_Shotgun = 4,
  EWT_SniperRifle = 5,
  EWT_MachineGun = 6,
  EWT_C4 = 7,
  EWT_Grenade = 8,
  EWT_Equipment = 9,
  EWT_StackableItem = 10,
  EWT_Unknown = 11,
};

bool EWeaponType_IsValid(int value);
constexpr EWeaponType EWeaponType_MIN = static_cast<EWeaponType>(0);
constexpr EWeaponType EWeaponType_MAX = static_cast<EWeaponType>(11);
constexpr int EWeaponType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
EWeaponType_descriptor();
template <typename T>
const std::string& EWeaponType_Name(T value) {
  static_assert(std::is_same<T, EWeaponType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EWeaponType_Name().");
  return EWeaponType_Name(static_cast<EWeaponType>(value));
}
template <>
inline const std::string& EWeaponType_Name(EWeaponType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EWeaponType_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool EWeaponType_Parse(absl::string_view name, EWeaponType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWeaponType>(
      EWeaponType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MLDict final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLDict) */ {
 public:
  inline MLDict() : MLDict(nullptr) {}
  ~MLDict() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLDict(::google::protobuf::internal::ConstantInitialized);

  MLDict(const MLDict& from);
  MLDict(MLDict&& from) noexcept
    : MLDict() {
    *this = ::std::move(from);
  }

  inline MLDict& operator=(const MLDict& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDict& operator=(MLDict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDict& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLDict* internal_default_instance() {
    return reinterpret_cast<const MLDict*>(
               &_MLDict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MLDict& a, MLDict& b) {
    a.Swap(&b);
  }
  inline void Swap(MLDict* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDict* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDict* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLDict>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLDict& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLDict& from) {
    MLDict::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLDict* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLDict";
  }
  protected:
  explicit MLDict(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValStringFieldNumber = 2,
    kValIntFieldNumber = 3,
    kValFloatFieldNumber = 4,
  };
  // optional string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string val_string = 2;
  bool has_val_string() const;
  void clear_val_string() ;
  const std::string& val_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_val_string(Arg_&& arg, Args_... args);
  std::string* mutable_val_string();
  PROTOBUF_NODISCARD std::string* release_val_string();
  void set_allocated_val_string(std::string* ptr);

  private:
  const std::string& _internal_val_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val_string(
      const std::string& value);
  std::string* _internal_mutable_val_string();

  public:
  // optional int32 val_int = 3;
  bool has_val_int() const;
  void clear_val_int() ;
  ::int32_t val_int() const;
  void set_val_int(::int32_t value);

  private:
  ::int32_t _internal_val_int() const;
  void _internal_set_val_int(::int32_t value);

  public:
  // optional float val_float = 4;
  bool has_val_float() const;
  void clear_val_float() ;
  float val_float() const;
  void set_val_float(float value);

  private:
  float _internal_val_float() const;
  void _internal_set_val_float(float value);

  public:
  // @@protoc_insertion_point(class_scope:MLDict)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 28, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr val_string_;
    ::int32_t val_int_;
    float val_float_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLEvent) */ {
 public:
  inline MLEvent() : MLEvent(nullptr) {}
  ~MLEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLEvent(::google::protobuf::internal::ConstantInitialized);

  MLEvent(const MLEvent& from);
  MLEvent(MLEvent&& from) noexcept
    : MLEvent() {
    *this = ::std::move(from);
  }

  inline MLEvent& operator=(const MLEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLEvent& operator=(MLEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLEvent* internal_default_instance() {
    return reinterpret_cast<const MLEvent*>(
               &_MLEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MLEvent& a, MLEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MLEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLEvent& from) {
    MLEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLEvent";
  }
  protected:
  explicit MLEvent(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kEventNameFieldNumber = 1,
  };
  // repeated .MLDict data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::MLDict* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::MLDict >*
      mutable_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::MLDict>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::MLDict>* _internal_mutable_data();
  public:
  const ::MLDict& data(int index) const;
  ::MLDict* add_data();
  const ::google::protobuf::RepeatedPtrField< ::MLDict >&
      data() const;
  // optional string event_name = 1;
  bool has_event_name() const;
  void clear_event_name() ;
  const std::string& event_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_name(Arg_&& arg, Args_... args);
  std::string* mutable_event_name();
  PROTOBUF_NODISCARD std::string* release_event_name();
  void set_allocated_event_name(std::string* ptr);

  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(
      const std::string& value);
  std::string* _internal_mutable_event_name();

  public:
  // @@protoc_insertion_point(class_scope:MLEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 26, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLDict > data_;
    ::google::protobuf::internal::ArenaStringPtr event_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLMatchState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLMatchState) */ {
 public:
  inline MLMatchState() : MLMatchState(nullptr) {}
  ~MLMatchState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLMatchState(::google::protobuf::internal::ConstantInitialized);

  MLMatchState(const MLMatchState& from);
  MLMatchState(MLMatchState&& from) noexcept
    : MLMatchState() {
    *this = ::std::move(from);
  }

  inline MLMatchState& operator=(const MLMatchState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLMatchState& operator=(MLMatchState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLMatchState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLMatchState* internal_default_instance() {
    return reinterpret_cast<const MLMatchState*>(
               &_MLMatchState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MLMatchState& a, MLMatchState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLMatchState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLMatchState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLMatchState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLMatchState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLMatchState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLMatchState& from) {
    MLMatchState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLMatchState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLMatchState";
  }
  protected:
  explicit MLMatchState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameModeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kRoundFieldNumber = 3,
    kScoreCtFieldNumber = 4,
    kScoreTFieldNumber = 5,
  };
  // optional string game_mode = 1;
  bool has_game_mode() const;
  void clear_game_mode() ;
  const std::string& game_mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_mode(Arg_&& arg, Args_... args);
  std::string* mutable_game_mode();
  PROTOBUF_NODISCARD std::string* release_game_mode();
  void set_allocated_game_mode(std::string* ptr);

  private:
  const std::string& _internal_game_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_mode(
      const std::string& value);
  std::string* _internal_mutable_game_mode();

  public:
  // optional string phase = 2;
  bool has_phase() const;
  void clear_phase() ;
  const std::string& phase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phase(Arg_&& arg, Args_... args);
  std::string* mutable_phase();
  PROTOBUF_NODISCARD std::string* release_phase();
  void set_allocated_phase(std::string* ptr);

  private:
  const std::string& _internal_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phase(
      const std::string& value);
  std::string* _internal_mutable_phase();

  public:
  // optional int32 round = 3;
  bool has_round() const;
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // optional int32 score_ct = 4;
  bool has_score_ct() const;
  void clear_score_ct() ;
  ::int32_t score_ct() const;
  void set_score_ct(::int32_t value);

  private:
  ::int32_t _internal_score_ct() const;
  void _internal_set_score_ct(::int32_t value);

  public:
  // optional int32 score_t = 5;
  bool has_score_t() const;
  void clear_score_t() ;
  ::int32_t score_t() const;
  void set_score_t(::int32_t value);

  private:
  ::int32_t _internal_score_t() const;
  void _internal_set_score_t(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLMatchState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 35, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr game_mode_;
    ::google::protobuf::internal::ArenaStringPtr phase_;
    ::int32_t round_;
    ::int32_t score_ct_;
    ::int32_t score_t_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLRoundState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLRoundState) */ {
 public:
  inline MLRoundState() : MLRoundState(nullptr) {}
  ~MLRoundState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLRoundState(::google::protobuf::internal::ConstantInitialized);

  MLRoundState(const MLRoundState& from);
  MLRoundState(MLRoundState&& from) noexcept
    : MLRoundState() {
    *this = ::std::move(from);
  }

  inline MLRoundState& operator=(const MLRoundState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLRoundState& operator=(MLRoundState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLRoundState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLRoundState* internal_default_instance() {
    return reinterpret_cast<const MLRoundState*>(
               &_MLRoundState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MLRoundState& a, MLRoundState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLRoundState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLRoundState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLRoundState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLRoundState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLRoundState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLRoundState& from) {
    MLRoundState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLRoundState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLRoundState";
  }
  protected:
  explicit MLRoundState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhaseFieldNumber = 1,
    kBombStateFieldNumber = 3,
    kWinTeamFieldNumber = 2,
  };
  // optional string phase = 1;
  bool has_phase() const;
  void clear_phase() ;
  const std::string& phase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phase(Arg_&& arg, Args_... args);
  std::string* mutable_phase();
  PROTOBUF_NODISCARD std::string* release_phase();
  void set_allocated_phase(std::string* ptr);

  private:
  const std::string& _internal_phase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phase(
      const std::string& value);
  std::string* _internal_mutable_phase();

  public:
  // optional string bomb_state = 3;
  bool has_bomb_state() const;
  void clear_bomb_state() ;
  const std::string& bomb_state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bomb_state(Arg_&& arg, Args_... args);
  std::string* mutable_bomb_state();
  PROTOBUF_NODISCARD std::string* release_bomb_state();
  void set_allocated_bomb_state(std::string* ptr);

  private:
  const std::string& _internal_bomb_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bomb_state(
      const std::string& value);
  std::string* _internal_mutable_bomb_state();

  public:
  // optional .ETeam win_team = 2 [default = ET_Unknown];
  bool has_win_team() const;
  void clear_win_team() ;
  ::ETeam win_team() const;
  void set_win_team(::ETeam value);

  private:
  ::ETeam _internal_win_team() const;
  void _internal_set_win_team(::ETeam value);

  public:
  // @@protoc_insertion_point(class_scope:MLRoundState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phase_;
    ::google::protobuf::internal::ArenaStringPtr bomb_state_;
    int win_team_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLWeaponState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLWeaponState) */ {
 public:
  inline MLWeaponState() : MLWeaponState(nullptr) {}
  ~MLWeaponState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLWeaponState(::google::protobuf::internal::ConstantInitialized);

  MLWeaponState(const MLWeaponState& from);
  MLWeaponState(MLWeaponState&& from) noexcept
    : MLWeaponState() {
    *this = ::std::move(from);
  }

  inline MLWeaponState& operator=(const MLWeaponState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLWeaponState& operator=(MLWeaponState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLWeaponState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLWeaponState* internal_default_instance() {
    return reinterpret_cast<const MLWeaponState*>(
               &_MLWeaponState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MLWeaponState& a, MLWeaponState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLWeaponState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLWeaponState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLWeaponState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLWeaponState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLWeaponState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLWeaponState& from) {
    MLWeaponState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLWeaponState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLWeaponState";
  }
  protected:
  explicit MLWeaponState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStateFieldNumber = 7,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 3,
    kAmmoClipFieldNumber = 4,
    kAmmoClipMaxFieldNumber = 5,
    kAmmoReserveFieldNumber = 6,
    kRecoilIndexFieldNumber = 8,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string state = 7;
  bool has_state() const;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* ptr);

  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(
      const std::string& value);
  std::string* _internal_mutable_state();

  public:
  // optional int32 index = 1;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // optional .EWeaponType type = 3 [default = EWT_Knife];
  bool has_type() const;
  void clear_type() ;
  ::EWeaponType type() const;
  void set_type(::EWeaponType value);

  private:
  ::EWeaponType _internal_type() const;
  void _internal_set_type(::EWeaponType value);

  public:
  // optional int32 ammo_clip = 4;
  bool has_ammo_clip() const;
  void clear_ammo_clip() ;
  ::int32_t ammo_clip() const;
  void set_ammo_clip(::int32_t value);

  private:
  ::int32_t _internal_ammo_clip() const;
  void _internal_set_ammo_clip(::int32_t value);

  public:
  // optional int32 ammo_clip_max = 5;
  bool has_ammo_clip_max() const;
  void clear_ammo_clip_max() ;
  ::int32_t ammo_clip_max() const;
  void set_ammo_clip_max(::int32_t value);

  private:
  ::int32_t _internal_ammo_clip_max() const;
  void _internal_set_ammo_clip_max(::int32_t value);

  public:
  // optional int32 ammo_reserve = 6;
  bool has_ammo_reserve() const;
  void clear_ammo_reserve() ;
  ::int32_t ammo_reserve() const;
  void set_ammo_reserve(::int32_t value);

  private:
  ::int32_t _internal_ammo_reserve() const;
  void _internal_set_ammo_reserve(::int32_t value);

  public:
  // optional float recoil_index = 8;
  bool has_recoil_index() const;
  void clear_recoil_index() ;
  float recoil_index() const;
  void set_recoil_index(float value);

  private:
  float _internal_recoil_index() const;
  void _internal_set_recoil_index(float value);

  public:
  // @@protoc_insertion_point(class_scope:MLWeaponState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::int32_t index_;
    int type_;
    ::int32_t ammo_clip_;
    ::int32_t ammo_clip_max_;
    ::int32_t ammo_reserve_;
    float recoil_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLPlayerState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLPlayerState) */ {
 public:
  inline MLPlayerState() : MLPlayerState(nullptr) {}
  ~MLPlayerState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLPlayerState(::google::protobuf::internal::ConstantInitialized);

  MLPlayerState(const MLPlayerState& from);
  MLPlayerState(MLPlayerState&& from) noexcept
    : MLPlayerState() {
    *this = ::std::move(from);
  }

  inline MLPlayerState& operator=(const MLPlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLPlayerState& operator=(MLPlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLPlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLPlayerState* internal_default_instance() {
    return reinterpret_cast<const MLPlayerState*>(
               &_MLPlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MLPlayerState& a, MLPlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLPlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLPlayerState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLPlayerState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLPlayerState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLPlayerState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLPlayerState& from) {
    MLPlayerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLPlayerState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLPlayerState";
  }
  protected:
  explicit MLPlayerState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponsFieldNumber = 20,
    kNameFieldNumber = 4,
    kClanFieldNumber = 5,
    kAbsposFieldNumber = 7,
    kEyeangleFieldNumber = 8,
    kEyeangleFwdFieldNumber = 9,
    kAccountIdFieldNumber = 1,
    kEntindexFieldNumber = 3,
    kTeamFieldNumber = 6,
    kHealthFieldNumber = 10,
    kArmorFieldNumber = 11,
    kFlashedFieldNumber = 12,
    kSmokedFieldNumber = 13,
    kMoneyFieldNumber = 14,
    kRoundKillsFieldNumber = 15,
    kRoundKillhsFieldNumber = 16,
    kBurningFieldNumber = 17,
    kHelmetFieldNumber = 18,
    kDefuseKitFieldNumber = 19,
    kPlayerSlotFieldNumber = 2,
  };
  // repeated .MLWeaponState weapons = 20;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;

  public:
  void clear_weapons() ;
  ::MLWeaponState* mutable_weapons(int index);
  ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
      mutable_weapons();
  private:
  const ::google::protobuf::RepeatedPtrField<::MLWeaponState>& _internal_weapons() const;
  ::google::protobuf::RepeatedPtrField<::MLWeaponState>* _internal_mutable_weapons();
  public:
  const ::MLWeaponState& weapons(int index) const;
  ::MLWeaponState* add_weapons();
  const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
      weapons() const;
  // optional string name = 4;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string clan = 5;
  bool has_clan() const;
  void clear_clan() ;
  const std::string& clan() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clan(Arg_&& arg, Args_... args);
  std::string* mutable_clan();
  PROTOBUF_NODISCARD std::string* release_clan();
  void set_allocated_clan(std::string* ptr);

  private:
  const std::string& _internal_clan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clan(
      const std::string& value);
  std::string* _internal_mutable_clan();

  public:
  // optional .CMsgVector abspos = 7;
  bool has_abspos() const;
  void clear_abspos() ;
  const ::CMsgVector& abspos() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_abspos();
  ::CMsgVector* mutable_abspos();
  void set_allocated_abspos(::CMsgVector* value);
  void unsafe_arena_set_allocated_abspos(::CMsgVector* value);
  ::CMsgVector* unsafe_arena_release_abspos();

  private:
  const ::CMsgVector& _internal_abspos() const;
  ::CMsgVector* _internal_mutable_abspos();

  public:
  // optional .CMsgQAngle eyeangle = 8;
  bool has_eyeangle() const;
  void clear_eyeangle() ;
  const ::CMsgQAngle& eyeangle() const;
  PROTOBUF_NODISCARD ::CMsgQAngle* release_eyeangle();
  ::CMsgQAngle* mutable_eyeangle();
  void set_allocated_eyeangle(::CMsgQAngle* value);
  void unsafe_arena_set_allocated_eyeangle(::CMsgQAngle* value);
  ::CMsgQAngle* unsafe_arena_release_eyeangle();

  private:
  const ::CMsgQAngle& _internal_eyeangle() const;
  ::CMsgQAngle* _internal_mutable_eyeangle();

  public:
  // optional .CMsgVector eyeangle_fwd = 9;
  bool has_eyeangle_fwd() const;
  void clear_eyeangle_fwd() ;
  const ::CMsgVector& eyeangle_fwd() const;
  PROTOBUF_NODISCARD ::CMsgVector* release_eyeangle_fwd();
  ::CMsgVector* mutable_eyeangle_fwd();
  void set_allocated_eyeangle_fwd(::CMsgVector* value);
  void unsafe_arena_set_allocated_eyeangle_fwd(::CMsgVector* value);
  ::CMsgVector* unsafe_arena_release_eyeangle_fwd();

  private:
  const ::CMsgVector& _internal_eyeangle_fwd() const;
  ::CMsgVector* _internal_mutable_eyeangle_fwd();

  public:
  // optional int32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id() ;
  ::int32_t account_id() const;
  void set_account_id(::int32_t value);

  private:
  ::int32_t _internal_account_id() const;
  void _internal_set_account_id(::int32_t value);

  public:
  // optional int32 entindex = 3;
  bool has_entindex() const;
  void clear_entindex() ;
  ::int32_t entindex() const;
  void set_entindex(::int32_t value);

  private:
  ::int32_t _internal_entindex() const;
  void _internal_set_entindex(::int32_t value);

  public:
  // optional .ETeam team = 6 [default = ET_Unknown];
  bool has_team() const;
  void clear_team() ;
  ::ETeam team() const;
  void set_team(::ETeam value);

  private:
  ::ETeam _internal_team() const;
  void _internal_set_team(::ETeam value);

  public:
  // optional int32 health = 10;
  bool has_health() const;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // optional int32 armor = 11;
  bool has_armor() const;
  void clear_armor() ;
  ::int32_t armor() const;
  void set_armor(::int32_t value);

  private:
  ::int32_t _internal_armor() const;
  void _internal_set_armor(::int32_t value);

  public:
  // optional float flashed = 12;
  bool has_flashed() const;
  void clear_flashed() ;
  float flashed() const;
  void set_flashed(float value);

  private:
  float _internal_flashed() const;
  void _internal_set_flashed(float value);

  public:
  // optional float smoked = 13;
  bool has_smoked() const;
  void clear_smoked() ;
  float smoked() const;
  void set_smoked(float value);

  private:
  float _internal_smoked() const;
  void _internal_set_smoked(float value);

  public:
  // optional int32 money = 14;
  bool has_money() const;
  void clear_money() ;
  ::int32_t money() const;
  void set_money(::int32_t value);

  private:
  ::int32_t _internal_money() const;
  void _internal_set_money(::int32_t value);

  public:
  // optional int32 round_kills = 15;
  bool has_round_kills() const;
  void clear_round_kills() ;
  ::int32_t round_kills() const;
  void set_round_kills(::int32_t value);

  private:
  ::int32_t _internal_round_kills() const;
  void _internal_set_round_kills(::int32_t value);

  public:
  // optional int32 round_killhs = 16;
  bool has_round_killhs() const;
  void clear_round_killhs() ;
  ::int32_t round_killhs() const;
  void set_round_killhs(::int32_t value);

  private:
  ::int32_t _internal_round_killhs() const;
  void _internal_set_round_killhs(::int32_t value);

  public:
  // optional float burning = 17;
  bool has_burning() const;
  void clear_burning() ;
  float burning() const;
  void set_burning(float value);

  private:
  float _internal_burning() const;
  void _internal_set_burning(float value);

  public:
  // optional bool helmet = 18;
  bool has_helmet() const;
  void clear_helmet() ;
  bool helmet() const;
  void set_helmet(bool value);

  private:
  bool _internal_helmet() const;
  void _internal_set_helmet(bool value);

  public:
  // optional bool defuse_kit = 19;
  bool has_defuse_kit() const;
  void clear_defuse_kit() ;
  bool defuse_kit() const;
  void set_defuse_kit(bool value);

  private:
  bool _internal_defuse_kit() const;
  void _internal_set_defuse_kit(bool value);

  public:
  // optional int32 player_slot = 2 [default = -1];
  bool has_player_slot() const;
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLPlayerState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 20, 5, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLWeaponState > weapons_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr clan_;
    ::CMsgVector* abspos_;
    ::CMsgQAngle* eyeangle_;
    ::CMsgVector* eyeangle_fwd_;
    ::int32_t account_id_;
    ::int32_t entindex_;
    int team_;
    ::int32_t health_;
    ::int32_t armor_;
    float flashed_;
    float smoked_;
    ::int32_t money_;
    ::int32_t round_kills_;
    ::int32_t round_killhs_;
    float burning_;
    bool helmet_;
    bool defuse_kit_;
    ::int32_t player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLGameState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLGameState) */ {
 public:
  inline MLGameState() : MLGameState(nullptr) {}
  ~MLGameState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLGameState(::google::protobuf::internal::ConstantInitialized);

  MLGameState(const MLGameState& from);
  MLGameState(MLGameState&& from) noexcept
    : MLGameState() {
    *this = ::std::move(from);
  }

  inline MLGameState& operator=(const MLGameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLGameState& operator=(MLGameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLGameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLGameState* internal_default_instance() {
    return reinterpret_cast<const MLGameState*>(
               &_MLGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MLGameState& a, MLGameState& b) {
    a.Swap(&b);
  }
  inline void Swap(MLGameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLGameState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLGameState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLGameState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLGameState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLGameState& from) {
    MLGameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLGameState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLGameState";
  }
  protected:
  explicit MLGameState(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kMatchFieldNumber = 1,
    kRoundFieldNumber = 2,
  };
  // repeated .MLPlayerState players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::MLPlayerState* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::MLPlayerState>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::MLPlayerState>* _internal_mutable_players();
  public:
  const ::MLPlayerState& players(int index) const;
  ::MLPlayerState* add_players();
  const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
      players() const;
  // optional .MLMatchState match = 1;
  bool has_match() const;
  void clear_match() ;
  const ::MLMatchState& match() const;
  PROTOBUF_NODISCARD ::MLMatchState* release_match();
  ::MLMatchState* mutable_match();
  void set_allocated_match(::MLMatchState* value);
  void unsafe_arena_set_allocated_match(::MLMatchState* value);
  ::MLMatchState* unsafe_arena_release_match();

  private:
  const ::MLMatchState& _internal_match() const;
  ::MLMatchState* _internal_mutable_match();

  public:
  // optional .MLRoundState round = 2;
  bool has_round() const;
  void clear_round() ;
  const ::MLRoundState& round() const;
  PROTOBUF_NODISCARD ::MLRoundState* release_round();
  ::MLRoundState* mutable_round();
  void set_allocated_round(::MLRoundState* value);
  void unsafe_arena_set_allocated_round(::MLRoundState* value);
  ::MLRoundState* unsafe_arena_release_round();

  private:
  const ::MLRoundState& _internal_round() const;
  ::MLRoundState* _internal_mutable_round();

  public:
  // @@protoc_insertion_point(class_scope:MLGameState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLPlayerState > players_;
    ::MLMatchState* match_;
    ::MLRoundState* round_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLDemoHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLDemoHeader) */ {
 public:
  inline MLDemoHeader() : MLDemoHeader(nullptr) {}
  ~MLDemoHeader() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLDemoHeader(::google::protobuf::internal::ConstantInitialized);

  MLDemoHeader(const MLDemoHeader& from);
  MLDemoHeader(MLDemoHeader&& from) noexcept
    : MLDemoHeader() {
    *this = ::std::move(from);
  }

  inline MLDemoHeader& operator=(const MLDemoHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDemoHeader& operator=(MLDemoHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDemoHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLDemoHeader* internal_default_instance() {
    return reinterpret_cast<const MLDemoHeader*>(
               &_MLDemoHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MLDemoHeader& a, MLDemoHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(MLDemoHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDemoHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDemoHeader* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLDemoHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLDemoHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLDemoHeader& from) {
    MLDemoHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLDemoHeader* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLDemoHeader";
  }
  protected:
  explicit MLDemoHeader(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
    kTickRateFieldNumber = 2,
    kVersionFieldNumber = 3,
    kSteamUniverseFieldNumber = 4,
  };
  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name() ;
  const std::string& map_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_map_name(Arg_&& arg, Args_... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* ptr);

  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(
      const std::string& value);
  std::string* _internal_mutable_map_name();

  public:
  // optional int32 tick_rate = 2;
  bool has_tick_rate() const;
  void clear_tick_rate() ;
  ::int32_t tick_rate() const;
  void set_tick_rate(::int32_t value);

  private:
  ::int32_t _internal_tick_rate() const;
  void _internal_set_tick_rate(::int32_t value);

  public:
  // optional uint32 version = 3;
  bool has_version() const;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // optional uint32 steam_universe = 4;
  bool has_steam_universe() const;
  void clear_steam_universe() ;
  ::uint32_t steam_universe() const;
  void set_steam_universe(::uint32_t value);

  private:
  ::uint32_t _internal_steam_universe() const;
  void _internal_set_steam_universe(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLDemoHeader)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 29, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr map_name_;
    ::int32_t tick_rate_;
    ::uint32_t version_;
    ::uint32_t steam_universe_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class MLTick final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MLTick) */ {
 public:
  inline MLTick() : MLTick(nullptr) {}
  ~MLTick() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MLTick(::google::protobuf::internal::ConstantInitialized);

  MLTick(const MLTick& from);
  MLTick(MLTick&& from) noexcept
    : MLTick() {
    *this = ::std::move(from);
  }

  inline MLTick& operator=(const MLTick& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLTick& operator=(MLTick&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLTick& default_instance() {
    return *internal_default_instance();
  }
  static inline const MLTick* internal_default_instance() {
    return reinterpret_cast<const MLTick*>(
               &_MLTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MLTick& a, MLTick& b) {
    a.Swap(&b);
  }
  inline void Swap(MLTick* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLTick* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLTick* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MLTick>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLTick& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MLTick& from) {
    MLTick::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLTick* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "MLTick";
  }
  protected:
  explicit MLTick(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kStateFieldNumber = 2,
    kTickCountFieldNumber = 1,
  };
  // repeated .MLEvent events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::MLEvent* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::MLEvent >*
      mutable_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::MLEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::MLEvent>* _internal_mutable_events();
  public:
  const ::MLEvent& events(int index) const;
  ::MLEvent* add_events();
  const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
      events() const;
  // optional .MLGameState state = 2;
  bool has_state() const;
  void clear_state() ;
  const ::MLGameState& state() const;
  PROTOBUF_NODISCARD ::MLGameState* release_state();
  ::MLGameState* mutable_state();
  void set_allocated_state(::MLGameState* value);
  void unsafe_arena_set_allocated_state(::MLGameState* value);
  ::MLGameState* unsafe_arena_release_state();

  private:
  const ::MLGameState& _internal_state() const;
  ::MLGameState* _internal_mutable_state();

  public:
  // optional int32 tick_count = 1;
  bool has_tick_count() const;
  void clear_tick_count() ;
  ::int32_t tick_count() const;
  void set_tick_count(::int32_t value);

  private:
  ::int32_t _internal_tick_count() const;
  void _internal_set_tick_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLTick)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLEvent > events_;
    ::MLGameState* state_;
    ::int32_t tick_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};// -------------------------------------------------------------------

class VacNetShot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VacNetShot) */ {
 public:
  inline VacNetShot() : VacNetShot(nullptr) {}
  ~VacNetShot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VacNetShot(::google::protobuf::internal::ConstantInitialized);

  VacNetShot(const VacNetShot& from);
  VacNetShot(VacNetShot&& from) noexcept
    : VacNetShot() {
    *this = ::std::move(from);
  }

  inline VacNetShot& operator=(const VacNetShot& from) {
    CopyFrom(from);
    return *this;
  }
  inline VacNetShot& operator=(VacNetShot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VacNetShot& default_instance() {
    return *internal_default_instance();
  }
  static inline const VacNetShot* internal_default_instance() {
    return reinterpret_cast<const VacNetShot*>(
               &_VacNetShot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VacNetShot& a, VacNetShot& b) {
    a.Swap(&b);
  }
  inline void Swap(VacNetShot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VacNetShot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VacNetShot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VacNetShot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VacNetShot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VacNetShot& from) {
    VacNetShot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VacNetShot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "VacNetShot";
  }
  protected:
  explicit VacNetShot(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaYawWindowFieldNumber = 6,
    kDeltaPitchWindowFieldNumber = 7,
    kSteamidPlayerFieldNumber = 1,
    kRoundNumberFieldNumber = 2,
    kHitTypeFieldNumber = 3,
    kWeaponTypeFieldNumber = 4,
    kDistanceToHurtTargetFieldNumber = 5,
  };
  // repeated float delta_yaw_window = 6;
  int delta_yaw_window_size() const;
  private:
  int _internal_delta_yaw_window_size() const;

  public:
  void clear_delta_yaw_window() ;
  float delta_yaw_window(int index) const;
  void set_delta_yaw_window(int index, float value);
  void add_delta_yaw_window(float value);
  const ::google::protobuf::RepeatedField<float>& delta_yaw_window() const;
  ::google::protobuf::RepeatedField<float>* mutable_delta_yaw_window();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_delta_yaw_window() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_delta_yaw_window();

  public:
  // repeated float delta_pitch_window = 7;
  int delta_pitch_window_size() const;
  private:
  int _internal_delta_pitch_window_size() const;

  public:
  void clear_delta_pitch_window() ;
  float delta_pitch_window(int index) const;
  void set_delta_pitch_window(int index, float value);
  void add_delta_pitch_window(float value);
  const ::google::protobuf::RepeatedField<float>& delta_pitch_window() const;
  ::google::protobuf::RepeatedField<float>* mutable_delta_pitch_window();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_delta_pitch_window() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_delta_pitch_window();

  public:
  // optional fixed64 steamid_player = 1;
  bool has_steamid_player() const;
  void clear_steamid_player() ;
  ::uint64_t steamid_player() const;
  void set_steamid_player(::uint64_t value);

  private:
  ::uint64_t _internal_steamid_player() const;
  void _internal_set_steamid_player(::uint64_t value);

  public:
  // optional int32 round_number = 2;
  bool has_round_number() const;
  void clear_round_number() ;
  ::int32_t round_number() const;
  void set_round_number(::int32_t value);

  private:
  ::int32_t _internal_round_number() const;
  void _internal_set_round_number(::int32_t value);

  public:
  // optional int32 hit_type = 3;
  bool has_hit_type() const;
  void clear_hit_type() ;
  ::int32_t hit_type() const;
  void set_hit_type(::int32_t value);

  private:
  ::int32_t _internal_hit_type() const;
  void _internal_set_hit_type(::int32_t value);

  public:
  // optional int32 weapon_type = 4;
  bool has_weapon_type() const;
  void clear_weapon_type() ;
  ::int32_t weapon_type() const;
  void set_weapon_type(::int32_t value);

  private:
  ::int32_t _internal_weapon_type() const;
  void _internal_set_weapon_type(::int32_t value);

  public:
  // optional float distance_to_hurt_target = 5;
  bool has_distance_to_hurt_target() const;
  void clear_distance_to_hurt_target() ;
  float distance_to_hurt_target() const;
  void set_distance_to_hurt_target(float value);

  private:
  float _internal_distance_to_hurt_target() const;
  void _internal_set_distance_to_hurt_target(float value);

  public:
  // @@protoc_insertion_point(class_scope:VacNetShot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> delta_yaw_window_;
    ::google::protobuf::RepeatedField<float> delta_pitch_window_;
    ::uint64_t steamid_player_;
    ::int32_t round_number_;
    ::int32_t hit_type_;
    ::int32_t weapon_type_;
    float distance_to_hurt_target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MLDict

// optional string key = 1;
inline bool MLDict::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLDict::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDict::key() const {
  // @@protoc_insertion_point(field_get:MLDict.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLDict::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDict.key)
}
inline std::string* MLDict::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:MLDict.key)
  return _s;
}
inline const std::string& MLDict::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void MLDict::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDict::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* MLDict::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLDict.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLDict::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDict.key)
}

// optional string val_string = 2;
inline bool MLDict::has_val_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLDict::clear_val_string() {
  _impl_.val_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLDict::val_string() const {
  // @@protoc_insertion_point(field_get:MLDict.val_string)
  return _internal_val_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLDict::set_val_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDict.val_string)
}
inline std::string* MLDict::mutable_val_string() {
  std::string* _s = _internal_mutable_val_string();
  // @@protoc_insertion_point(field_mutable:MLDict.val_string)
  return _s;
}
inline const std::string& MLDict::_internal_val_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.val_string_.Get();
}
inline void MLDict::_internal_set_val_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_string_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDict::_internal_mutable_val_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.val_string_.Mutable( GetArenaForAllocation());
}
inline std::string* MLDict::release_val_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLDict.val_string)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.val_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.val_string_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLDict::set_allocated_val_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.val_string_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.val_string_.IsDefault()) {
          _impl_.val_string_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDict.val_string)
}

// optional int32 val_int = 3;
inline bool MLDict::has_val_int() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLDict::clear_val_int() {
  _impl_.val_int_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLDict::val_int() const {
  // @@protoc_insertion_point(field_get:MLDict.val_int)
  return _internal_val_int();
}
inline void MLDict::set_val_int(::int32_t value) {
  _internal_set_val_int(value);
  // @@protoc_insertion_point(field_set:MLDict.val_int)
}
inline ::int32_t MLDict::_internal_val_int() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.val_int_;
}
inline void MLDict::_internal_set_val_int(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.val_int_ = value;
}

// optional float val_float = 4;
inline bool MLDict::has_val_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLDict::clear_val_float() {
  _impl_.val_float_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MLDict::val_float() const {
  // @@protoc_insertion_point(field_get:MLDict.val_float)
  return _internal_val_float();
}
inline void MLDict::set_val_float(float value) {
  _internal_set_val_float(value);
  // @@protoc_insertion_point(field_set:MLDict.val_float)
}
inline float MLDict::_internal_val_float() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.val_float_;
}
inline void MLDict::_internal_set_val_float(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.val_float_ = value;
}

// -------------------------------------------------------------------

// MLEvent

// optional string event_name = 1;
inline bool MLEvent::has_event_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLEvent::clear_event_name() {
  _impl_.event_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLEvent::event_name() const {
  // @@protoc_insertion_point(field_get:MLEvent.event_name)
  return _internal_event_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLEvent::set_event_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLEvent.event_name)
}
inline std::string* MLEvent::mutable_event_name() {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:MLEvent.event_name)
  return _s;
}
inline const std::string& MLEvent::_internal_event_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_name_.Get();
}
inline void MLEvent::_internal_set_event_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLEvent::_internal_mutable_event_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.event_name_.Mutable( GetArenaForAllocation());
}
inline std::string* MLEvent::release_event_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLEvent.event_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.event_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.event_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLEvent::set_allocated_event_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.event_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.event_name_.IsDefault()) {
          _impl_.event_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLEvent.event_name)
}

// repeated .MLDict data = 2;
inline int MLEvent::_internal_data_size() const {
  return _internal_data().size();
}
inline int MLEvent::data_size() const {
  return _internal_data_size();
}
inline void MLEvent::clear_data() {
  _internal_mutable_data()->Clear();
}
inline ::MLDict* MLEvent::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:MLEvent.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MLDict >*
MLEvent::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MLEvent.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::MLDict& MLEvent::data(int index) const {
  // @@protoc_insertion_point(field_get:MLEvent.data)
    return _internal_data().Get(index);
}
inline ::MLDict* MLEvent::add_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::MLDict* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:MLEvent.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLDict >&
MLEvent::data() const {
  // @@protoc_insertion_point(field_list:MLEvent.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::MLDict>&
MLEvent::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::MLDict>*
MLEvent::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// MLMatchState

// optional string game_mode = 1;
inline bool MLMatchState::has_game_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLMatchState::clear_game_mode() {
  _impl_.game_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLMatchState::game_mode() const {
  // @@protoc_insertion_point(field_get:MLMatchState.game_mode)
  return _internal_game_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLMatchState::set_game_mode(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLMatchState.game_mode)
}
inline std::string* MLMatchState::mutable_game_mode() {
  std::string* _s = _internal_mutable_game_mode();
  // @@protoc_insertion_point(field_mutable:MLMatchState.game_mode)
  return _s;
}
inline const std::string& MLMatchState::_internal_game_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.game_mode_.Get();
}
inline void MLMatchState::_internal_set_game_mode(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* MLMatchState::_internal_mutable_game_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.game_mode_.Mutable( GetArenaForAllocation());
}
inline std::string* MLMatchState::release_game_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLMatchState.game_mode)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.game_mode_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_mode_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLMatchState::set_allocated_game_mode(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.game_mode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.game_mode_.IsDefault()) {
          _impl_.game_mode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.game_mode)
}

// optional string phase = 2;
inline bool MLMatchState::has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLMatchState::clear_phase() {
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLMatchState::phase() const {
  // @@protoc_insertion_point(field_get:MLMatchState.phase)
  return _internal_phase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLMatchState::set_phase(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLMatchState.phase)
}
inline std::string* MLMatchState::mutable_phase() {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLMatchState.phase)
  return _s;
}
inline const std::string& MLMatchState::_internal_phase() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phase_.Get();
}
inline void MLMatchState::_internal_set_phase(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_.Set(value, GetArenaForAllocation());
}
inline std::string* MLMatchState::_internal_mutable_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.phase_.Mutable( GetArenaForAllocation());
}
inline std::string* MLMatchState::release_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLMatchState.phase)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.phase_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phase_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLMatchState::set_allocated_phase(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phase_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phase_.IsDefault()) {
          _impl_.phase_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.phase)
}

// optional int32 round = 3;
inline bool MLMatchState::has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLMatchState::clear_round() {
  _impl_.round_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLMatchState::round() const {
  // @@protoc_insertion_point(field_get:MLMatchState.round)
  return _internal_round();
}
inline void MLMatchState::set_round(::int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:MLMatchState.round)
}
inline ::int32_t MLMatchState::_internal_round() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.round_;
}
inline void MLMatchState::_internal_set_round(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.round_ = value;
}

// optional int32 score_ct = 4;
inline bool MLMatchState::has_score_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLMatchState::clear_score_ct() {
  _impl_.score_ct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MLMatchState::score_ct() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_ct)
  return _internal_score_ct();
}
inline void MLMatchState::set_score_ct(::int32_t value) {
  _internal_set_score_ct(value);
  // @@protoc_insertion_point(field_set:MLMatchState.score_ct)
}
inline ::int32_t MLMatchState::_internal_score_ct() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_ct_;
}
inline void MLMatchState::_internal_set_score_ct(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.score_ct_ = value;
}

// optional int32 score_t = 5;
inline bool MLMatchState::has_score_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MLMatchState::clear_score_t() {
  _impl_.score_t_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MLMatchState::score_t() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_t)
  return _internal_score_t();
}
inline void MLMatchState::set_score_t(::int32_t value) {
  _internal_set_score_t(value);
  // @@protoc_insertion_point(field_set:MLMatchState.score_t)
}
inline ::int32_t MLMatchState::_internal_score_t() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.score_t_;
}
inline void MLMatchState::_internal_set_score_t(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.score_t_ = value;
}

// -------------------------------------------------------------------

// MLRoundState

// optional string phase = 1;
inline bool MLRoundState::has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLRoundState::clear_phase() {
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLRoundState::phase() const {
  // @@protoc_insertion_point(field_get:MLRoundState.phase)
  return _internal_phase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLRoundState::set_phase(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLRoundState.phase)
}
inline std::string* MLRoundState::mutable_phase() {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLRoundState.phase)
  return _s;
}
inline const std::string& MLRoundState::_internal_phase() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phase_.Get();
}
inline void MLRoundState::_internal_set_phase(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(value, GetArenaForAllocation());
}
inline std::string* MLRoundState::_internal_mutable_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phase_.Mutable( GetArenaForAllocation());
}
inline std::string* MLRoundState::release_phase() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLRoundState.phase)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phase_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phase_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLRoundState::set_allocated_phase(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phase_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phase_.IsDefault()) {
          _impl_.phase_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.phase)
}

// optional .ETeam win_team = 2 [default = ET_Unknown];
inline bool MLRoundState::has_win_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLRoundState::clear_win_team() {
  _impl_.win_team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ETeam MLRoundState::win_team() const {
  // @@protoc_insertion_point(field_get:MLRoundState.win_team)
  return _internal_win_team();
}
inline void MLRoundState::set_win_team(::ETeam value) {
  _internal_set_win_team(value);
  // @@protoc_insertion_point(field_set:MLRoundState.win_team)
}
inline ::ETeam MLRoundState::_internal_win_team() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ETeam>(_impl_.win_team_);
}
inline void MLRoundState::_internal_set_win_team(::ETeam value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ETeam_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.win_team_ = value;
}

// optional string bomb_state = 3;
inline bool MLRoundState::has_bomb_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLRoundState::clear_bomb_state() {
  _impl_.bomb_state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLRoundState::bomb_state() const {
  // @@protoc_insertion_point(field_get:MLRoundState.bomb_state)
  return _internal_bomb_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLRoundState::set_bomb_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bomb_state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLRoundState.bomb_state)
}
inline std::string* MLRoundState::mutable_bomb_state() {
  std::string* _s = _internal_mutable_bomb_state();
  // @@protoc_insertion_point(field_mutable:MLRoundState.bomb_state)
  return _s;
}
inline const std::string& MLRoundState::_internal_bomb_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bomb_state_.Get();
}
inline void MLRoundState::_internal_set_bomb_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bomb_state_.Set(value, GetArenaForAllocation());
}
inline std::string* MLRoundState::_internal_mutable_bomb_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bomb_state_.Mutable( GetArenaForAllocation());
}
inline std::string* MLRoundState::release_bomb_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLRoundState.bomb_state)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bomb_state_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bomb_state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLRoundState::set_allocated_bomb_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bomb_state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bomb_state_.IsDefault()) {
          _impl_.bomb_state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.bomb_state)
}

// -------------------------------------------------------------------

// MLWeaponState

// optional int32 index = 1;
inline bool MLWeaponState::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLWeaponState::clear_index() {
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLWeaponState::index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.index)
  return _internal_index();
}
inline void MLWeaponState::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.index)
}
inline ::int32_t MLWeaponState::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void MLWeaponState::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}

// optional string name = 2;
inline bool MLWeaponState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLWeaponState::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLWeaponState::name() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLWeaponState::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLWeaponState.name)
}
inline std::string* MLWeaponState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.name)
  return _s;
}
inline const std::string& MLWeaponState::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MLWeaponState::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLWeaponState::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* MLWeaponState::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLWeaponState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLWeaponState::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.name)
}

// optional .EWeaponType type = 3 [default = EWT_Knife];
inline bool MLWeaponState::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLWeaponState::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::EWeaponType MLWeaponState::type() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.type)
  return _internal_type();
}
inline void MLWeaponState::set_type(::EWeaponType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.type)
}
inline ::EWeaponType MLWeaponState::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::EWeaponType>(_impl_.type_);
}
inline void MLWeaponState::_internal_set_type(::EWeaponType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::EWeaponType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}

// optional int32 ammo_clip = 4;
inline bool MLWeaponState::has_ammo_clip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_clip() {
  _impl_.ammo_clip_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MLWeaponState::ammo_clip() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip)
  return _internal_ammo_clip();
}
inline void MLWeaponState::set_ammo_clip(::int32_t value) {
  _internal_set_ammo_clip(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip)
}
inline ::int32_t MLWeaponState::_internal_ammo_clip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ammo_clip_;
}
inline void MLWeaponState::_internal_set_ammo_clip(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.ammo_clip_ = value;
}

// optional int32 ammo_clip_max = 5;
inline bool MLWeaponState::has_ammo_clip_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_clip_max() {
  _impl_.ammo_clip_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MLWeaponState::ammo_clip_max() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip_max)
  return _internal_ammo_clip_max();
}
inline void MLWeaponState::set_ammo_clip_max(::int32_t value) {
  _internal_set_ammo_clip_max(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip_max)
}
inline ::int32_t MLWeaponState::_internal_ammo_clip_max() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ammo_clip_max_;
}
inline void MLWeaponState::_internal_set_ammo_clip_max(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ammo_clip_max_ = value;
}

// optional int32 ammo_reserve = 6;
inline bool MLWeaponState::has_ammo_reserve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_reserve() {
  _impl_.ammo_reserve_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MLWeaponState::ammo_reserve() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_reserve)
  return _internal_ammo_reserve();
}
inline void MLWeaponState::set_ammo_reserve(::int32_t value) {
  _internal_set_ammo_reserve(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_reserve)
}
inline ::int32_t MLWeaponState::_internal_ammo_reserve() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ammo_reserve_;
}
inline void MLWeaponState::_internal_set_ammo_reserve(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ammo_reserve_ = value;
}

// optional string state = 7;
inline bool MLWeaponState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLWeaponState::clear_state() {
  _impl_.state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLWeaponState::state() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLWeaponState::set_state(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLWeaponState.state)
}
inline std::string* MLWeaponState::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.state)
  return _s;
}
inline const std::string& MLWeaponState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_.Get();
}
inline void MLWeaponState::_internal_set_state(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* MLWeaponState::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.state_.Mutable( GetArenaForAllocation());
}
inline std::string* MLWeaponState::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLWeaponState.state)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.state_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.state_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLWeaponState::set_allocated_state(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_.IsDefault()) {
          _impl_.state_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.state)
}

// optional float recoil_index = 8;
inline bool MLWeaponState::has_recoil_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MLWeaponState::clear_recoil_index() {
  _impl_.recoil_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MLWeaponState::recoil_index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.recoil_index)
  return _internal_recoil_index();
}
inline void MLWeaponState::set_recoil_index(float value) {
  _internal_set_recoil_index(value);
  // @@protoc_insertion_point(field_set:MLWeaponState.recoil_index)
}
inline float MLWeaponState::_internal_recoil_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recoil_index_;
}
inline void MLWeaponState::_internal_set_recoil_index(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.recoil_index_ = value;
}

// -------------------------------------------------------------------

// MLPlayerState

// optional int32 account_id = 1;
inline bool MLPlayerState::has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MLPlayerState::clear_account_id() {
  _impl_.account_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MLPlayerState::account_id() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.account_id)
  return _internal_account_id();
}
inline void MLPlayerState::set_account_id(::int32_t value) {
  _internal_set_account_id(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.account_id)
}
inline ::int32_t MLPlayerState::_internal_account_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_id_;
}
inline void MLPlayerState::_internal_set_account_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.account_id_ = value;
}

// optional int32 player_slot = 2 [default = -1];
inline bool MLPlayerState::has_player_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void MLPlayerState::clear_player_slot() {
  _impl_.player_slot_ = -1;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int32_t MLPlayerState::player_slot() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.player_slot)
  return _internal_player_slot();
}
inline void MLPlayerState::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.player_slot)
}
inline ::int32_t MLPlayerState::_internal_player_slot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_slot_;
}
inline void MLPlayerState::_internal_set_player_slot(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.player_slot_ = value;
}

// optional int32 entindex = 3;
inline bool MLPlayerState::has_entindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MLPlayerState::clear_entindex() {
  _impl_.entindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MLPlayerState::entindex() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.entindex)
  return _internal_entindex();
}
inline void MLPlayerState::set_entindex(::int32_t value) {
  _internal_set_entindex(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.entindex)
}
inline ::int32_t MLPlayerState::_internal_entindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entindex_;
}
inline void MLPlayerState::_internal_set_entindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.entindex_ = value;
}

// optional string name = 4;
inline bool MLPlayerState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLPlayerState::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLPlayerState::name() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLPlayerState::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLPlayerState.name)
}
inline std::string* MLPlayerState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.name)
  return _s;
}
inline const std::string& MLPlayerState::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void MLPlayerState::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLPlayerState::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* MLPlayerState::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLPlayerState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLPlayerState::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.name)
}

// optional string clan = 5;
inline bool MLPlayerState::has_clan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLPlayerState::clear_clan() {
  _impl_.clan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLPlayerState::clan() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.clan)
  return _internal_clan();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLPlayerState::set_clan(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clan_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLPlayerState.clan)
}
inline std::string* MLPlayerState::mutable_clan() {
  std::string* _s = _internal_mutable_clan();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.clan)
  return _s;
}
inline const std::string& MLPlayerState::_internal_clan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clan_.Get();
}
inline void MLPlayerState::_internal_set_clan(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clan_.Set(value, GetArenaForAllocation());
}
inline std::string* MLPlayerState::_internal_mutable_clan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.clan_.Mutable( GetArenaForAllocation());
}
inline std::string* MLPlayerState::release_clan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLPlayerState.clan)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.clan_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.clan_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLPlayerState::set_allocated_clan(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.clan_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clan_.IsDefault()) {
          _impl_.clan_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.clan)
}

// optional .ETeam team = 6 [default = ET_Unknown];
inline bool MLPlayerState::has_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MLPlayerState::clear_team() {
  _impl_.team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ETeam MLPlayerState::team() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.team)
  return _internal_team();
}
inline void MLPlayerState::set_team(::ETeam value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.team)
}
inline ::ETeam MLPlayerState::_internal_team() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ETeam>(_impl_.team_);
}
inline void MLPlayerState::_internal_set_team(::ETeam value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::ETeam_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.team_ = value;
}

// optional .CMsgVector abspos = 7;
inline bool MLPlayerState::has_abspos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.abspos_ != nullptr);
  return value;
}
inline const ::CMsgVector& MLPlayerState::_internal_abspos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgVector* p = _impl_.abspos_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::abspos() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.abspos)
  return _internal_abspos();
}
inline void MLPlayerState::unsafe_arena_set_allocated_abspos(::CMsgVector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.abspos_);
  }
  _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.abspos)
}
inline ::CMsgVector* MLPlayerState::release_abspos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* released = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgVector* MLPlayerState::unsafe_arena_release_abspos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLPlayerState.abspos)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
  return temp;
}
inline ::CMsgVector* MLPlayerState::_internal_mutable_abspos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.abspos_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(p);
  }
  return _impl_.abspos_;
}
inline ::CMsgVector* MLPlayerState::mutable_abspos() {
  ::CMsgVector* _msg = _internal_mutable_abspos();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.abspos)
  return _msg;
}
inline void MLPlayerState::set_allocated_abspos(::CMsgVector* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.abspos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.abspos)
}

// optional .CMsgQAngle eyeangle = 8;
inline bool MLPlayerState::has_eyeangle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_ != nullptr);
  return value;
}
inline const ::CMsgQAngle& MLPlayerState::_internal_eyeangle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgQAngle* p = _impl_.eyeangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& MLPlayerState::eyeangle() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle)
  return _internal_eyeangle();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle(::CMsgQAngle* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_);
  }
  _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle)
}
inline ::CMsgQAngle* MLPlayerState::release_eyeangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* released = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgQAngle* MLPlayerState::unsafe_arena_release_eyeangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* temp = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* MLPlayerState::_internal_mutable_eyeangle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.eyeangle_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgQAngle>(GetArenaForAllocation());
    _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(p);
  }
  return _impl_.eyeangle_;
}
inline ::CMsgQAngle* MLPlayerState::mutable_eyeangle() {
  ::CMsgQAngle* _msg = _internal_mutable_eyeangle();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle(::CMsgQAngle* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle)
}

// optional .CMsgVector eyeangle_fwd = 9;
inline bool MLPlayerState::has_eyeangle_fwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_fwd_ != nullptr);
  return value;
}
inline const ::CMsgVector& MLPlayerState::_internal_eyeangle_fwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::CMsgVector* p = _impl_.eyeangle_fwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::eyeangle_fwd() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle_fwd)
  return _internal_eyeangle_fwd();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle_fwd(::CMsgVector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_fwd_);
  }
  _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle_fwd)
}
inline ::CMsgVector* MLPlayerState::release_eyeangle_fwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* released = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::CMsgVector* MLPlayerState::unsafe_arena_release_eyeangle_fwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle_fwd)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* temp = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
  return temp;
}
inline ::CMsgVector* MLPlayerState::_internal_mutable_eyeangle_fwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.eyeangle_fwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgVector>(GetArenaForAllocation());
    _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(p);
  }
  return _impl_.eyeangle_fwd_;
}
inline ::CMsgVector* MLPlayerState::mutable_eyeangle_fwd() {
  ::CMsgVector* _msg = _internal_mutable_eyeangle_fwd();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle_fwd)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle_fwd(::CMsgVector* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_fwd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle_fwd)
}

// optional int32 health = 10;
inline bool MLPlayerState::has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MLPlayerState::clear_health() {
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t MLPlayerState::health() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.health)
  return _internal_health();
}
inline void MLPlayerState::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.health)
}
inline ::int32_t MLPlayerState::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void MLPlayerState::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.health_ = value;
}

// optional int32 armor = 11;
inline bool MLPlayerState::has_armor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MLPlayerState::clear_armor() {
  _impl_.armor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t MLPlayerState::armor() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.armor)
  return _internal_armor();
}
inline void MLPlayerState::set_armor(::int32_t value) {
  _internal_set_armor(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.armor)
}
inline ::int32_t MLPlayerState::_internal_armor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.armor_;
}
inline void MLPlayerState::_internal_set_armor(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.armor_ = value;
}

// optional float flashed = 12;
inline bool MLPlayerState::has_flashed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void MLPlayerState::clear_flashed() {
  _impl_.flashed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float MLPlayerState::flashed() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.flashed)
  return _internal_flashed();
}
inline void MLPlayerState::set_flashed(float value) {
  _internal_set_flashed(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.flashed)
}
inline float MLPlayerState::_internal_flashed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flashed_;
}
inline void MLPlayerState::_internal_set_flashed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.flashed_ = value;
}

// optional float smoked = 13;
inline bool MLPlayerState::has_smoked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void MLPlayerState::clear_smoked() {
  _impl_.smoked_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float MLPlayerState::smoked() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.smoked)
  return _internal_smoked();
}
inline void MLPlayerState::set_smoked(float value) {
  _internal_set_smoked(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.smoked)
}
inline float MLPlayerState::_internal_smoked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.smoked_;
}
inline void MLPlayerState::_internal_set_smoked(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.smoked_ = value;
}

// optional int32 money = 14;
inline bool MLPlayerState::has_money() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void MLPlayerState::clear_money() {
  _impl_.money_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t MLPlayerState::money() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.money)
  return _internal_money();
}
inline void MLPlayerState::set_money(::int32_t value) {
  _internal_set_money(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.money)
}
inline ::int32_t MLPlayerState::_internal_money() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.money_;
}
inline void MLPlayerState::_internal_set_money(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.money_ = value;
}

// optional int32 round_kills = 15;
inline bool MLPlayerState::has_round_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MLPlayerState::clear_round_kills() {
  _impl_.round_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t MLPlayerState::round_kills() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_kills)
  return _internal_round_kills();
}
inline void MLPlayerState::set_round_kills(::int32_t value) {
  _internal_set_round_kills(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.round_kills)
}
inline ::int32_t MLPlayerState::_internal_round_kills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.round_kills_;
}
inline void MLPlayerState::_internal_set_round_kills(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.round_kills_ = value;
}

// optional int32 round_killhs = 16;
inline bool MLPlayerState::has_round_killhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void MLPlayerState::clear_round_killhs() {
  _impl_.round_killhs_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t MLPlayerState::round_killhs() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_killhs)
  return _internal_round_killhs();
}
inline void MLPlayerState::set_round_killhs(::int32_t value) {
  _internal_set_round_killhs(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.round_killhs)
}
inline ::int32_t MLPlayerState::_internal_round_killhs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.round_killhs_;
}
inline void MLPlayerState::_internal_set_round_killhs(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.round_killhs_ = value;
}

// optional float burning = 17;
inline bool MLPlayerState::has_burning() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void MLPlayerState::clear_burning() {
  _impl_.burning_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float MLPlayerState::burning() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.burning)
  return _internal_burning();
}
inline void MLPlayerState::set_burning(float value) {
  _internal_set_burning(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.burning)
}
inline float MLPlayerState::_internal_burning() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.burning_;
}
inline void MLPlayerState::_internal_set_burning(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.burning_ = value;
}

// optional bool helmet = 18;
inline bool MLPlayerState::has_helmet() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void MLPlayerState::clear_helmet() {
  _impl_.helmet_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool MLPlayerState::helmet() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.helmet)
  return _internal_helmet();
}
inline void MLPlayerState::set_helmet(bool value) {
  _internal_set_helmet(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.helmet)
}
inline bool MLPlayerState::_internal_helmet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.helmet_;
}
inline void MLPlayerState::_internal_set_helmet(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.helmet_ = value;
}

// optional bool defuse_kit = 19;
inline bool MLPlayerState::has_defuse_kit() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void MLPlayerState::clear_defuse_kit() {
  _impl_.defuse_kit_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool MLPlayerState::defuse_kit() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.defuse_kit)
  return _internal_defuse_kit();
}
inline void MLPlayerState::set_defuse_kit(bool value) {
  _internal_set_defuse_kit(value);
  // @@protoc_insertion_point(field_set:MLPlayerState.defuse_kit)
}
inline bool MLPlayerState::_internal_defuse_kit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defuse_kit_;
}
inline void MLPlayerState::_internal_set_defuse_kit(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.defuse_kit_ = value;
}

// repeated .MLWeaponState weapons = 20;
inline int MLPlayerState::_internal_weapons_size() const {
  return _internal_weapons().size();
}
inline int MLPlayerState::weapons_size() const {
  return _internal_weapons_size();
}
inline void MLPlayerState::clear_weapons() {
  _internal_mutable_weapons()->Clear();
}
inline ::MLWeaponState* MLPlayerState::mutable_weapons(int index) {
  // @@protoc_insertion_point(field_mutable:MLPlayerState.weapons)
  return _internal_mutable_weapons()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MLWeaponState >*
MLPlayerState::mutable_weapons() {
  // @@protoc_insertion_point(field_mutable_list:MLPlayerState.weapons)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_weapons();
}
inline const ::MLWeaponState& MLPlayerState::weapons(int index) const {
  // @@protoc_insertion_point(field_get:MLPlayerState.weapons)
    return _internal_weapons().Get(index);
}
inline ::MLWeaponState* MLPlayerState::add_weapons() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::MLWeaponState* _add = _internal_mutable_weapons()->Add();
  // @@protoc_insertion_point(field_add:MLPlayerState.weapons)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLWeaponState >&
MLPlayerState::weapons() const {
  // @@protoc_insertion_point(field_list:MLPlayerState.weapons)
  return _internal_weapons();
}
inline const ::google::protobuf::RepeatedPtrField<::MLWeaponState>&
MLPlayerState::_internal_weapons() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapons_;
}
inline ::google::protobuf::RepeatedPtrField<::MLWeaponState>*
MLPlayerState::_internal_mutable_weapons() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.weapons_;
}

// -------------------------------------------------------------------

// MLGameState

// optional .MLMatchState match = 1;
inline bool MLGameState::has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void MLGameState::clear_match() {
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLMatchState& MLGameState::_internal_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MLMatchState* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLMatchState&>(::_MLMatchState_default_instance_);
}
inline const ::MLMatchState& MLGameState::match() const {
  // @@protoc_insertion_point(field_get:MLGameState.match)
  return _internal_match();
}
inline void MLGameState::unsafe_arena_set_allocated_match(::MLMatchState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::MLMatchState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.match)
}
inline ::MLMatchState* MLGameState::release_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* released = _impl_.match_;
  _impl_.match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MLMatchState* MLGameState::unsafe_arena_release_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLGameState.match)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::MLMatchState* MLGameState::_internal_mutable_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.match_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLMatchState>(GetArenaForAllocation());
    _impl_.match_ = reinterpret_cast<::MLMatchState*>(p);
  }
  return _impl_.match_;
}
inline ::MLMatchState* MLGameState::mutable_match() {
  ::MLMatchState* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:MLGameState.match)
  return _msg;
}
inline void MLGameState::set_allocated_match(::MLMatchState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::MLMatchState*>(_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::MLMatchState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.match_ = reinterpret_cast<::MLMatchState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLGameState.match)
}

// optional .MLRoundState round = 2;
inline bool MLGameState::has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.round_ != nullptr);
  return value;
}
inline void MLGameState::clear_round() {
  if (_impl_.round_ != nullptr) _impl_.round_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MLRoundState& MLGameState::_internal_round() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MLRoundState* p = _impl_.round_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLRoundState&>(::_MLRoundState_default_instance_);
}
inline const ::MLRoundState& MLGameState::round() const {
  // @@protoc_insertion_point(field_get:MLGameState.round)
  return _internal_round();
}
inline void MLGameState::unsafe_arena_set_allocated_round(::MLRoundState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.round_);
  }
  _impl_.round_ = reinterpret_cast<::MLRoundState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.round)
}
inline ::MLRoundState* MLGameState::release_round() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* released = _impl_.round_;
  _impl_.round_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MLRoundState* MLGameState::unsafe_arena_release_round() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLGameState.round)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* temp = _impl_.round_;
  _impl_.round_ = nullptr;
  return temp;
}
inline ::MLRoundState* MLGameState::_internal_mutable_round() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.round_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLRoundState>(GetArenaForAllocation());
    _impl_.round_ = reinterpret_cast<::MLRoundState*>(p);
  }
  return _impl_.round_;
}
inline ::MLRoundState* MLGameState::mutable_round() {
  ::MLRoundState* _msg = _internal_mutable_round();
  // @@protoc_insertion_point(field_mutable:MLGameState.round)
  return _msg;
}
inline void MLGameState::set_allocated_round(::MLRoundState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::MLRoundState*>(_impl_.round_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::MLRoundState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.round_ = reinterpret_cast<::MLRoundState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLGameState.round)
}

// repeated .MLPlayerState players = 3;
inline int MLGameState::_internal_players_size() const {
  return _internal_players().size();
}
inline int MLGameState::players_size() const {
  return _internal_players_size();
}
inline void MLGameState::clear_players() {
  _internal_mutable_players()->Clear();
}
inline ::MLPlayerState* MLGameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:MLGameState.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MLPlayerState >*
MLGameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:MLGameState.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::MLPlayerState& MLGameState::players(int index) const {
  // @@protoc_insertion_point(field_get:MLGameState.players)
    return _internal_players().Get(index);
}
inline ::MLPlayerState* MLGameState::add_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::MLPlayerState* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:MLGameState.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLPlayerState >&
MLGameState::players() const {
  // @@protoc_insertion_point(field_list:MLGameState.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::MLPlayerState>&
MLGameState::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::MLPlayerState>*
MLGameState::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// MLDemoHeader

// optional string map_name = 1;
inline bool MLDemoHeader::has_map_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLDemoHeader::clear_map_name() {
  _impl_.map_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDemoHeader::map_name() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.map_name)
  return _internal_map_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MLDemoHeader::set_map_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MLDemoHeader.map_name)
}
inline std::string* MLDemoHeader::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:MLDemoHeader.map_name)
  return _s;
}
inline const std::string& MLDemoHeader::_internal_map_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.map_name_.Get();
}
inline void MLDemoHeader::_internal_set_map_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MLDemoHeader::_internal_mutable_map_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_name_.Mutable( GetArenaForAllocation());
}
inline std::string* MLDemoHeader::release_map_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLDemoHeader.map_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.map_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MLDemoHeader::set_allocated_map_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.map_name_.IsDefault()) {
          _impl_.map_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MLDemoHeader.map_name)
}

// optional int32 tick_rate = 2;
inline bool MLDemoHeader::has_tick_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLDemoHeader::clear_tick_rate() {
  _impl_.tick_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MLDemoHeader::tick_rate() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.tick_rate)
  return _internal_tick_rate();
}
inline void MLDemoHeader::set_tick_rate(::int32_t value) {
  _internal_set_tick_rate(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.tick_rate)
}
inline ::int32_t MLDemoHeader::_internal_tick_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_rate_;
}
inline void MLDemoHeader::_internal_set_tick_rate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tick_rate_ = value;
}

// optional uint32 version = 3;
inline bool MLDemoHeader::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLDemoHeader::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t MLDemoHeader::version() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.version)
  return _internal_version();
}
inline void MLDemoHeader::set_version(::uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.version)
}
inline ::uint32_t MLDemoHeader::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void MLDemoHeader::_internal_set_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_ = value;
}

// optional uint32 steam_universe = 4;
inline bool MLDemoHeader::has_steam_universe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLDemoHeader::clear_steam_universe() {
  _impl_.steam_universe_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t MLDemoHeader::steam_universe() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.steam_universe)
  return _internal_steam_universe();
}
inline void MLDemoHeader::set_steam_universe(::uint32_t value) {
  _internal_set_steam_universe(value);
  // @@protoc_insertion_point(field_set:MLDemoHeader.steam_universe)
}
inline ::uint32_t MLDemoHeader::_internal_steam_universe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steam_universe_;
}
inline void MLDemoHeader::_internal_set_steam_universe(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.steam_universe_ = value;
}

// -------------------------------------------------------------------

// MLTick

// optional int32 tick_count = 1;
inline bool MLTick::has_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLTick::clear_tick_count() {
  _impl_.tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MLTick::tick_count() const {
  // @@protoc_insertion_point(field_get:MLTick.tick_count)
  return _internal_tick_count();
}
inline void MLTick::set_tick_count(::int32_t value) {
  _internal_set_tick_count(value);
  // @@protoc_insertion_point(field_set:MLTick.tick_count)
}
inline ::int32_t MLTick::_internal_tick_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_count_;
}
inline void MLTick::_internal_set_tick_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tick_count_ = value;
}

// optional .MLGameState state = 2;
inline bool MLTick::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void MLTick::clear_state() {
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLGameState& MLTick::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::MLGameState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLGameState&>(::_MLGameState_default_instance_);
}
inline const ::MLGameState& MLTick::state() const {
  // @@protoc_insertion_point(field_get:MLTick.state)
  return _internal_state();
}
inline void MLTick::unsafe_arena_set_allocated_state(::MLGameState* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::MLGameState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLTick.state)
}
inline ::MLGameState* MLTick::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* released = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::MLGameState* MLTick::unsafe_arena_release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:MLTick.state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::MLGameState* MLTick::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::MLGameState>(GetArenaForAllocation());
    _impl_.state_ = reinterpret_cast<::MLGameState*>(p);
  }
  return _impl_.state_;
}
inline ::MLGameState* MLTick::mutable_state() {
  ::MLGameState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLTick.state)
  return _msg;
}
inline void MLTick::set_allocated_state(::MLGameState* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::MLGameState*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::MLGameState*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.state_ = reinterpret_cast<::MLGameState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLTick.state)
}

// repeated .MLEvent events = 3;
inline int MLTick::_internal_events_size() const {
  return _internal_events().size();
}
inline int MLTick::events_size() const {
  return _internal_events_size();
}
inline void MLTick::clear_events() {
  _internal_mutable_events()->Clear();
}
inline ::MLEvent* MLTick::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:MLTick.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MLEvent >*
MLTick::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:MLTick.events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_events();
}
inline const ::MLEvent& MLTick::events(int index) const {
  // @@protoc_insertion_point(field_get:MLTick.events)
    return _internal_events().Get(index);
}
inline ::MLEvent* MLTick::add_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::MLEvent* _add = _internal_mutable_events()->Add();
  // @@protoc_insertion_point(field_add:MLTick.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::MLEvent >&
MLTick::events() const {
  // @@protoc_insertion_point(field_list:MLTick.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::MLEvent>&
MLTick::_internal_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::MLEvent>*
MLTick::_internal_mutable_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// VacNetShot

// optional fixed64 steamid_player = 1;
inline bool VacNetShot::has_steamid_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VacNetShot::clear_steamid_player() {
  _impl_.steamid_player_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t VacNetShot::steamid_player() const {
  // @@protoc_insertion_point(field_get:VacNetShot.steamid_player)
  return _internal_steamid_player();
}
inline void VacNetShot::set_steamid_player(::uint64_t value) {
  _internal_set_steamid_player(value);
  // @@protoc_insertion_point(field_set:VacNetShot.steamid_player)
}
inline ::uint64_t VacNetShot::_internal_steamid_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steamid_player_;
}
inline void VacNetShot::_internal_set_steamid_player(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steamid_player_ = value;
}

// optional int32 round_number = 2;
inline bool VacNetShot::has_round_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VacNetShot::clear_round_number() {
  _impl_.round_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t VacNetShot::round_number() const {
  // @@protoc_insertion_point(field_get:VacNetShot.round_number)
  return _internal_round_number();
}
inline void VacNetShot::set_round_number(::int32_t value) {
  _internal_set_round_number(value);
  // @@protoc_insertion_point(field_set:VacNetShot.round_number)
}
inline ::int32_t VacNetShot::_internal_round_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.round_number_;
}
inline void VacNetShot::_internal_set_round_number(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.round_number_ = value;
}

// optional int32 hit_type = 3;
inline bool VacNetShot::has_hit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VacNetShot::clear_hit_type() {
  _impl_.hit_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t VacNetShot::hit_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.hit_type)
  return _internal_hit_type();
}
inline void VacNetShot::set_hit_type(::int32_t value) {
  _internal_set_hit_type(value);
  // @@protoc_insertion_point(field_set:VacNetShot.hit_type)
}
inline ::int32_t VacNetShot::_internal_hit_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hit_type_;
}
inline void VacNetShot::_internal_set_hit_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.hit_type_ = value;
}

// optional int32 weapon_type = 4;
inline bool VacNetShot::has_weapon_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VacNetShot::clear_weapon_type() {
  _impl_.weapon_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t VacNetShot::weapon_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.weapon_type)
  return _internal_weapon_type();
}
inline void VacNetShot::set_weapon_type(::int32_t value) {
  _internal_set_weapon_type(value);
  // @@protoc_insertion_point(field_set:VacNetShot.weapon_type)
}
inline ::int32_t VacNetShot::_internal_weapon_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_type_;
}
inline void VacNetShot::_internal_set_weapon_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.weapon_type_ = value;
}

// optional float distance_to_hurt_target = 5;
inline bool VacNetShot::has_distance_to_hurt_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VacNetShot::clear_distance_to_hurt_target() {
  _impl_.distance_to_hurt_target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VacNetShot::distance_to_hurt_target() const {
  // @@protoc_insertion_point(field_get:VacNetShot.distance_to_hurt_target)
  return _internal_distance_to_hurt_target();
}
inline void VacNetShot::set_distance_to_hurt_target(float value) {
  _internal_set_distance_to_hurt_target(value);
  // @@protoc_insertion_point(field_set:VacNetShot.distance_to_hurt_target)
}
inline float VacNetShot::_internal_distance_to_hurt_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_to_hurt_target_;
}
inline void VacNetShot::_internal_set_distance_to_hurt_target(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.distance_to_hurt_target_ = value;
}

// repeated float delta_yaw_window = 6;
inline int VacNetShot::_internal_delta_yaw_window_size() const {
  return _internal_delta_yaw_window().size();
}
inline int VacNetShot::delta_yaw_window_size() const {
  return _internal_delta_yaw_window_size();
}
inline void VacNetShot::clear_delta_yaw_window() {
  _internal_mutable_delta_yaw_window()->Clear();
}
inline float VacNetShot::delta_yaw_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window().Get(index);
}
inline void VacNetShot::set_delta_yaw_window(int index, float value) {
  _internal_mutable_delta_yaw_window()->Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_yaw_window)
}
inline void VacNetShot::add_delta_yaw_window(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_delta_yaw_window()->Add(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_yaw_window)
}
inline const ::google::protobuf::RepeatedField<float>& VacNetShot::delta_yaw_window() const {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window();
}
inline ::google::protobuf::RepeatedField<float>* VacNetShot::mutable_delta_yaw_window() {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_yaw_window)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_delta_yaw_window();
}

inline const ::google::protobuf::RepeatedField<float>& VacNetShot::_internal_delta_yaw_window() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delta_yaw_window_;
}
inline ::google::protobuf::RepeatedField<float>* VacNetShot::_internal_mutable_delta_yaw_window() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.delta_yaw_window_;
}

// repeated float delta_pitch_window = 7;
inline int VacNetShot::_internal_delta_pitch_window_size() const {
  return _internal_delta_pitch_window().size();
}
inline int VacNetShot::delta_pitch_window_size() const {
  return _internal_delta_pitch_window_size();
}
inline void VacNetShot::clear_delta_pitch_window() {
  _internal_mutable_delta_pitch_window()->Clear();
}
inline float VacNetShot::delta_pitch_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window().Get(index);
}
inline void VacNetShot::set_delta_pitch_window(int index, float value) {
  _internal_mutable_delta_pitch_window()->Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_pitch_window)
}
inline void VacNetShot::add_delta_pitch_window(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_delta_pitch_window()->Add(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_pitch_window)
}
inline const ::google::protobuf::RepeatedField<float>& VacNetShot::delta_pitch_window() const {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window();
}
inline ::google::protobuf::RepeatedField<float>* VacNetShot::mutable_delta_pitch_window() {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_pitch_window)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_delta_pitch_window();
}

inline const ::google::protobuf::RepeatedField<float>& VacNetShot::_internal_delta_pitch_window() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delta_pitch_window_;
}
inline ::google::protobuf::RepeatedField<float>* VacNetShot::_internal_mutable_delta_pitch_window() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.delta_pitch_window_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::EHitGroup> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::EHitGroup>() {
  return ::EHitGroup_descriptor();
}
template <>
struct is_proto_enum<::ETeam> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ETeam>() {
  return ::ETeam_descriptor();
}
template <>
struct is_proto_enum<::EWeaponType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::EWeaponType>() {
  return ::EWeaponType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_fatdemo_2eproto_2epb_2eh
